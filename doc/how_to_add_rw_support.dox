/*
 * Copyright 2011-2012 Tanjeff-Nicolai Moos <tanjeff@cccmz.de>
 *
 * This file is part of the agentXcpp library.
 *
 * AgentXcpp is free software: you can redistribute it and/or modify
 * it under the terms of the AgentXcpp library license, version 1, which 
 * consists of the GNU General Public License and some additional 
 * permissions.
 *
 * AgentXcpp is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * See the AgentXcpp library license in the LICENSE file of this package 
 * for more details.
 */

/*! 


\page how_to_add_rw_support How to implement a writeable variable

\note This is a follow-up tutorial to \ref how_to_write_a_subagent.

In the previous tutorial we wrote a simple read-only counter variable. Here we 
will continue this work and add write support to the simpleCounter variable.  
Writing to the variable will set it to a new value, and it will continue to 
count from there.

The updated MIB looks like that:

\verbatim
SIMPLE-MIB DEFINITIONS ::= BEGIN

IMPORTS
    OBJECT-TYPE FROM SNMPv2-SMI
    enterprises FROM SNMPv2-SMI;

simpleCounter OBJECT-TYPE
    SYNTAX INTEGER
    ACCESS read-write
    STATUS current
    DESCRIPTION "A simple counter which is incremented each time
                 it is queried. Starts with 0."
    ::={ enterprises 42 1 }

END
\endverbatim

This is the same as before, but with "ACCESS read-write".

\section the_set_steps The anatomy of a Set request

A single SNMP Set request may set multiple variables at once (possibly 
distributed over multiple subagents), and SNMP guarantees an atomic operation 
in that case.  This means that, should any variable fail to perform the Set 
operation, no other variable is allowed to perform the set operation either.  
Therefore, the Set operation is carried out in multiple distinct steps:

-# \b TestSet checks whether the variable could be set at all. This step is 
   performed for all variables (in all subagents) affected by the single SNMP 
   request.  If any variable is not able to accept its new value, the Set 
   operation is aborted (and no variable gets updated). During this step 
   subagents shall allocate the resources they need to carry out the Set 
   operation later.
-# \b CommitSet actually sets the new value. This step may fail for a variable, 
   even if the TestSet step announced that the CommitSet would work. If that 
   happens, all other variables which already performed the CommitSet must undo 
   their action. It is strongly recommended to implement variables in such a 
   way that CommitSet does not fail, when possible.
-# The third step is one of the following:
   - \b CleanupSet is usually the last step, performed after CommitSet was 
     successful for all variables. In the CleanupSet step, the subagent shall 
     release any resources which where allocated in the TestSet step.
   - \b UndoSet is performed if CommitSet failed for any variable.  UndoSet is 
     then called for all variables which already performed CommitSet and 
     therefore must undo their action. For variables which didn't perform 
     CommitSet yet, CleanupSet is called instead. Like CleanupSet, UndoSet 
     shall also releases all resources which were allocated in the TestSet 
     step. 
     

To implement these actions, the \ref agentxcpp::Variable 
"Variable" class provides the methods \ref 
agentxcpp::Variable::undoset "testset()", \ref 
agentxcpp::Variable::undoset "commitset()", \ref 
agentxcpp::Variable::undoset "cleanupset()" and \ref 
agentxcpp::Variable::undoset "undoset()" which can be overridden by a 
concrete implementation.

\section extend_simplecounter Extending the SimpleCounter class

To implement write support for the SimpleCounter class, we implement all four 
methods. The \ref agentxcpp::Variable::undoset "testset()" 
implementation allocates an \ref agentxcpp::IntegerValue "IntegerValue" value, which is deallocated by \ref 
agentxcpp::Variable::undoset "cleanupset()" respectively \ref 
agentxcpp::Variable::undoset "undoset()". This is not very realistic, 
but it demonstrates the usage of the individual steps.


\subsection TestSet

The \ref agentxcpp::Variable::undoset "testset()" function must be 
overridden by any variable which should be writeable. If it is not overridden, 
agentXcpp assumes that the variable is read-only (which we exploited in the 
first, read-only version).  Hence, we implement it for our SimpleCounter class 
by adding the following code to it:

\code
    private:
        IntegerValue* old_value;

    public:
        virtual testset_result_t testset(shared_ptr<IntegerValue> new_value)
        {
            try
            {
                // Allocate space to store the old value
                old_value = new IntegerValue;
            }
            catch(std::bad_alloc)
            {
                // Resource allocation failed.
                return resourceUnavailable;
            }

            // setting the variable will succeed
            return noError;
        }
\endcode

The \ref agentxcpp::Variable::testset "testset()" method receives the 
value and can check whether setting the variable to this value would work.  
Here, we don't check the value, but we allocate an \ref agentxcpp::IntegerValue 
"IntegerValue" to store the old value, which is needed for \ref agentxcpp::Variable::undoset 
"undoset()". If allocation fails, we return the error 
\ref agentxcpp::AbstractVariable::resourceUnavailable "resourceUnavailable".


\subsection CommitSet

The \ref agentxcpp::Variable::commitset "commitset()" method must 
also be implemented for writeable variables. In the SimpleCounter class, this 
method sets the internal value and stores the old one, in case \ref 
agentxcpp::Variable::undoset "undoset()" is called:
\code
        virtual bool commitset(shared_ptr<IntegerValue> new_value)
        {
            // Remember old value for rollback
            *old_value = counter;

            // Set new value
            counter = *new_value;

            // Operation succeeded
            return true;
        }
\endcode

\subsection CleanupSet

The \ref agentxcpp::Variable::cleanupset "cleanupset()" method 
releases old_value again:

\code
        virtual void cleanupset(shared_ptr<IntegerValue> new_value)
        {
            // Release old value
            delete old_value;
        }
\endcode

If old_value were an IntegerValue (instead of a pointer to IntegerValue) no allocation 
and deallocation would have been necessary. The \ref 
agentxcpp::Variable::cleanupset "cleanupset()" method would not be 
implemented then.  In fact, this method is the only one which is optional for 
writeable variables, while the other methods are mandatory.

\subsection UndoSet

The \ref agentxcpp::Variable::undoset "undoset()" method must be 
implemented by each variable and perform a rollback. It is technically possible 
to omit this method; the compiler has no way to detect a missing 
implementation. However, it is an error to omit it, and an error will be 
reported to the master agent if it is missing. For simpleCounter implementation 
is easy:

\code
        virtual bool undoset(shared_ptr<IntegerValue> new_value)
        {
            // Restore old value
            counter = *old_value;

            // Release old value
            delete old_value;

            // Rollback succeeded
            return true;
        }
\endcode

It's important to note that the method releases old_value.

\section try_it_out Testing the extended subagent

Again, we compile and run the subagent. This is exactly the same as in the 
first tutorial (it is assumed that your system is already setup accordingly):

\verbatim
g++ simpleagent.cpp -o simpleagent -lboost_system -lpthread -lagentxcpp \
    `pkg-config --cflags --libs QtNetwork QtCore`
\endverbatim

Now we query the variable:

\verbatim
snmpget -v1 -c rw localhost SIMPLE-MIB::simpleCounter.0
\endverbatim

Each time the variable is queried, the counter increments. Now, let's set the 
counter to, say, 42:

\verbatim
snmpset -v1 -c rw localhost SIMPLE-MIB::simpleCounter.0 i 42
\endverbatim

Now, we continue to query it again several times and the counter should 
continue at 43, further incrementing.

Et voil√°: a read-write variable. Now go on and learn
\ref how_to_send_notifications "how to send notifications"!



*/

/*
 * Copyright 2011-2013 Tanjeff-Nicolai Moos <tanjeff@cccmz.de>
 *
 * This file is part of the agentXcpp library.
 *
 * AgentXcpp is free software: you can redistribute it and/or modify
 * it under the terms of the AgentXcpp library license, version 1, which 
 * consists of the GNU General Public License and some additional 
 * permissions.
 *
 * AgentXcpp is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * See the AgentXcpp library license in the LICENSE file of this package 
 * for more details.
 */

/*! 


\page how_to_implement_tables How to implement a table

\note This is a follow-up tutorial to \ref how_to_send_notifications.

So far we learned how to implement single variables and how to send 
notifications. This tutorial teaches us how an SNMP table can be implemented.  
Again, we start with what we did in the previous tutorials, and add a simple 
table to the SIMPLE-MIB:

\verbatim
SIMPLE-MIB DEFINITIONS ::= BEGIN

IMPORTS
    OBJECT-TYPE FROM SNMPv2-SMI
    enterprises FROM SNMPv2-SMI
    NOTIFICATION-TYPE FROM SNMPv2-SMI;

simpleCounter OBJECT-TYPE
    SYNTAX INTEGER
    ACCESS read-write
    STATUS current
    DESCRIPTION "A simple counter which is incremented each time
                 it is queried. Starts with 0."
    ::={ enterprises 42 1 }

simpleCounterStatus NOTIFICATION-TYPE
    OBJECTS { simpleCounter }
    STATUS current
    DESCRIPTION "A notification sent each second."
    ::={ enterprises 42 0 1 }

counterChangeTable OBJECT-TYPE
    SYNTAX SEQUENCE OF counterChangeEntry
    ACCESS not-accessible
    STATUS current
    DESCRIPTION "This table lists all changes of the simpleCounter object."
    ::= { enterprises 42 2 }

counterChangeEntry OBJECT-TYPE
    SYNTAX counterChangeEntry
    ACCESS not-accessible
    STATUS current
    DESCRIPTION "An entry within the counterChangeEntry table."
    INDEX { counterChangeEpoch, counterChangeMilliseconds }
    ::= { counterChangeTable 1 }
    counterChangeEntry ::= SEQUENCE {
        counterChangeEpoch               INTEGER,
        counterChangeMilliseconds        INTEGER,
        counterChangeTimeString          DisplayString,
        counterChangeCounterValue        INTEGER
    }

counterChangeEpoch OBJECT-TYPE
    SYNTAX INTEGER
    ACCESS read-only
    STATUS current
    DESCRIPTION "The time at which the change occured.This variable contains 
                 the epoch, i.e. seconds since 1970-01-01, 00:00."
    ::={ counterChangeEntry 1 }

counterChangeMilliseconds OBJECT-TYPE
    SYNTAX INTEGER
    ACCESS read-only
    STATUS current
    DESCRIPTION "The time at which counter changed. This variable contains the 
                 milliseconds since counterChangeEpoch, to increase 
                 precision."
    ::={ counterChangeEntry 2 }

counterChangeTimeString OBJECT-TYPE
    SYNTAX OCTETSTRING
    ACCESS read-only
    STATUS current
    DESCRIPTION "The time (counterChangeEpoch + counterChangeMilliseconds) as a 
    human-readable string."
    ::={ counterChangeEntry 3 }

counterChangeValue OBJECT-TYPE
    SYNTAX INTEGER
    ACCESS read-only
    STATUS current
    DESCRIPTION "The counter value right after the change."
    ::={ counterChangeEntry 4 }

END
\endverbatim

Our table has an entry for each counter change which occured in the past. The 
table starts empty and each time the counter changes (i.e. by an SNMP GET or 
SET request), an entry is added.

Each entry within the table has a timestamp, which consists of the epoch time 
and a milliseconds component. This is to show how multiple variables can be 
used to form the tables index. In addition, the time is reported in an 
human-readable format (e.g. "2011-09-11, 12:00:52.77"). Finally, each entry 
reports the new counter value.

*/

//\section implementing_the_variables Implementing the variables.
//
//First of all, we will create the variables notificationEventEpoch, 
//notificationEventMilliseconds, notificationEventTimeString and 
//notificationEventCounterValue. These are all read-only variable, therefore it 
//suffice to instantiate the stanard classes agentXcpp provides:
//
//\code
//    IntegerVariable notificationEventEpoch;
//    IntegerVariable notificationEventMilliseconds;
//    DisplayStringVariable notificationEventTimeString;
//    IntegerVariable notificationEventCounterValue;
//\endcode
//
//
//
//
//
//
//*/

/*
 * Copyright 2011-2012 Tanjeff-Nicolai Moos <tanjeff@cccmz.de>
 *
 * This file is part of the agentXcpp library.
 *
 * AgentXcpp is free software: you can redistribute it and/or modify
 * it under the terms of the AgentXcpp library license, version 1, which 
 * consists of the GNU General Public License and some additional 
 * permissions.
 *
 * AgentXcpp is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * See the AgentXcpp library license in the LICENSE file of this package 
 * for more details.
 */

/*! 


\page how_to_send_notifications How to send notifications and traps

\note This is a follow-up tutorial to \ref how_to_write_a_subagent.

This HOWTO explains how to send notifications (SNMP v2, v2c and v3) and traps 
(SNMP v1). Luckily, from a subagent's point of view, there is nearly no 
difference between traps and notifications. In the following text, the term 
"notification" is used for notifications \e and traps.

When a subagent detects some condition, it may send a notification to the 
master agent. The master agent will then forward it to some SNMP managers, 
depending on its configuration. The destination of the SNMP notification (or 
trap) is determined solely by the master agent.

We start with the subagent developed in \ref how_to_write_a_subagent, which 
provides the SNMP variable simpleCounter. This counter is incremented each time 
it is read. Next we will enhance our implementation to send a notification each 
time the counter value changes.

First of all, let's augment the SIMPLE-MIB known from \ref 
how_to_write_a_subagent. Here is the complete MIB:

\verbatim
SIMPLE-MIB DEFINITIONS ::= BEGIN

IMPORTS
    OBJECT-TYPE FROM SNMPv2-SMI
    enterprises FROM SNMPv2-SMI
    NOTIFICATION-TYPE FROM SNMPv2-SMI;

simpleCounter OBJECT-TYPE
    SYNTAX INTEGER
    ACCESS read-only
    STATUS current
    DESCRIPTION "A simple counter which is incremented each time
                 it is queried. Starts with 0."
    ::={ enterprises 42 1 }

simpleCounterChange NOTIFICATION-TYPE
    OBJECTS { simpleCounter }
    STATUS current
    DESCRIPTION "A notification sent whenever simpleCounter changes."
    ::={ enterprises 42 0 1 }

END
\endverbatim

As can be seen, we added the simpleCounterChange notification, which will 
include the simpleCounter value when sent. Note that the next-to-last 
subidentifier for notifications must be 0 according to RFC 1902, 8.5. "Mapping 
of the NOTIFICATION-TYPE value".


\section implementing_notification The Implementation




Now, how do we implement a notification? Normally, a subagent is just sitting 
there, waiting for SNMP requests and handling them. Notifications typically 
arise outside of this mechanism. The subagent might use another thread watching 
out for important events, and sending notifications (note, however, that 
agentXcpp is currently not thread-safe). Or, the subagent might be 
single-threaded, sharing an boost::asio::io_service object with the 
master_agent, so that events outside agentXcpp are handled together with 
agentXcpp internal events.

Our case is simpler, though, because \c simpleCounterChange notifications are
triggered by Get-Requests and thus synchronized with the SNMP activities. The 
easiest is to replace <tt>master.get_io_service()->run();</tt> by 
<tt>master.get_io_service()->run_one();</tt>, so that after each SNMP request, 
the main loop is left and control is given back to our program. Then, we test 
whether a notification must be sent, and if so, send it.

\note Sending notifications from within <tt>simpleCounter::get()</tt> doesn't 
      work.

Here is the new code, placed within the <tt>main()</tt> function:

\code
    while( master.is_connected() )
    {
        master.get_io_service()->run_one(); // serve one SNMP request

        // Send Notification if needed:
        if(counter->is_dirty())
        {
            std::cout << "Counter changed to " << counter->value() << std::endl;
            vector<varbind> objects;
            objects.push_back(varbind(simpleCounter_oid, counter));
            master.send_notification(oid(enterprises_oid, "42.0.1"), objects);
        }
    }
\endcode

\todo Which OID must be given to send_notification()?

For this to work, we must implement the <tt>simpleCounter::is_dirty()</tt> and 
<tt>simpleCounter::value()</tt> methods, which we'll do in a moment.

Here is what happens in this code fragment: The <tt>run_one()</tt> method 
blocks until one SNMP request is handled (while <tt>run()</tt> blocks forever 
as long as no error happens).  After this single event, <tt>run_one()</tt> 
returns, and a notification can be sent if needed.

If the counter is "dirty" (i.e. the value changed since the last call to 
<tt>is_dirty()</tt>), a vector<varbind> is created, and a \ref 
agentxcpp::varbind varbind is added with the simpleCounter's OID and the 
simpleCounter itself (the \c counter variable).  Then a notification is sent, 
which includes the varbind vector.

After that, the loop is repeated and <tt>run_one()</tt> is called to wait for 
the next SNMP request.

Next, we augment the class simpleCounter. Here is the complete class 
definition:

\code
class simpleCounter : public Integer
{
    private:
        int32_t counter;
        bool dirty;     // <-- NEW!

    public:
        virtual int32_t get()
        {
            // NEW: set dirty to true
            counter++;
            dirty = true;
            return counter;
        }

        simpleCounter()
            : counter(0), dirty(false) // add initialization of 'dirty'
        {
        }

        // NEW:
        bool is_dirty()
        {
            bool status = dirty;
            dirty = false;
            return status;
        }

        // New:
        int32_t value()
        {
            return counter;
        }
};
\endcode

The new <tt>value()</tt> method simply returns the current value. Further, we 
added the \c dirty flag, which is initially initialized to false. When the 
value is incremented (within <tt>get()</tt>), the \dirty flag is set to true.  
Asking for the flag with <tt>is_dirty()</tt> returns the state and resets the 
flag to false.






















\section compiling_notification Compiling the Subagent

Compiling subagent works exactly the same as in \ref how_to_write_a_subagent 
(depending on your development environment):

\code
g++ simpleagent.cpp -o simpleagent -lboost_system -lpthread -lagentxcpp
\endcode



\section running_notification Running the Subagent

The subagent is run as described in \ref how_to_write_a_subagent, but to make 
notifications work, you need additional configuration for the master agent. For 
the NET-SNMP master agent, add the following line to its configuration file 
<tt>/etc/snmp/snmpd.conf</tt>:

\verbatim
informsink udp:127.0.0.1 rw
\endverbatim

This line means that notifications are sent to the address 127.0.0.1, using the 
default port (which is 162) and the community string "rw" (which we also used
in \ref how_to_write_a_subagent). Next, we (re)start the master agent using its 
init scripts:

\verbatim
/etc/init.d/snmpd stop
/etc/init.d/snmpd start
\endverbatim

Note that the path depends on your system. For example in ArchLinux, it is 
/etc/rc.d/snmpd.


\subsection starting snmptrapd

To receive notifications, we use the snmptrapd program from the NET-SNMP 
package. First, we have to configure it. Make sure that the following line is 
contained in <tt>/etc/snmp/snmptrapd.conf</tt>:

\verbatim
authCommunity log rw
\endverbatim

That line enables logging for notifications with the community string "rw". Now 
start the program as root. The program must be run as root, because it needs to 
listen on the privileged port 162.

\verbatim
snmptrapd -f -Le
\endverbatim

The <tt>-f</tt> parameter forces the program to stay in the foreground, so we 
can see its output. The <tt>-Le</tt> parameter redirects the logging messages 
to stderr (i.e. to the console window).


\subsection starting_subagent Starting the Subagent

The subagent is started as last time:

\verbatim
./simpleagent
\endverbatim





\subsection provoke_notifications Provoking Notifications

We now provoke notifications by sending GET requests for the simpleCounter 
object:

\verbatim
snmpget -v1 -c rw localhost 1.3.6.1.4.1.42.1.0
\endverbatim

Each time the command is executed, the simpleCounter object reports the 
incremented number, and the snmptrapd program reports that a notification was 
received. The notification contains the current counter value.



*/

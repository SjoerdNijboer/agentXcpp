<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>AgentXcpp: agentxcpp::master_proxy Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">AgentXcpp
   &#160;<span id="projectnumber">Revision:0.1.1</span>
   </div>
   <div id="projectbrief">API Documentation</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classagentxcpp_1_1master__proxy.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">agentxcpp::master_proxy Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class represents the master agent in a subagent program.  
 <a href="classagentxcpp_1_1master__proxy.html#details">More...</a></p>

<p><code>#include &lt;master_proxy.hpp&gt;</code></p>

<p>Inherits agentxcpp::connector::pdu_handler.</p>

<p><a href="classagentxcpp_1_1master__proxy-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af6d8fdc6474185183a155b2bd6dc70fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1master__proxy.html#af6d8fdc6474185183a155b2bd6dc70fb">master_proxy</a> (boost::asio::io_service *io_service, std::string description=&quot;&quot;, uint8_t default_timeout=0, <a class="el" href="classagentxcpp_1_1oid.html">oid</a> ID=<a class="el" href="classagentxcpp_1_1oid.html">oid</a>(), std::string unix_domain_socket=&quot;/var/agentx/master&quot;)</td></tr>
<tr class="memdesc:af6d8fdc6474185183a155b2bd6dc70fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a session object connected via unix domain socket.  <a href="#af6d8fdc6474185183a155b2bd6dc70fb"></a><br/></td></tr>
<tr class="memitem:aca2d85c52b5be12bf5a25301f4014c4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1master__proxy.html#aca2d85c52b5be12bf5a25301f4014c4b">master_proxy</a> (std::string description=&quot;&quot;, uint8_t default_timeout=0, <a class="el" href="classagentxcpp_1_1oid.html">oid</a> ID=<a class="el" href="classagentxcpp_1_1oid.html">oid</a>(), std::string unix_domain_socket=&quot;/var/agentx/master&quot;)</td></tr>
<tr class="memdesc:aca2d85c52b5be12bf5a25301f4014c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a session object connected via unix domain socket.  <a href="#aca2d85c52b5be12bf5a25301f4014c4b"></a><br/></td></tr>
<tr class="memitem:a6c6a57de2c3f38721d44663e0bf34651"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1master__proxy.html#a6c6a57de2c3f38721d44663e0bf34651">register_subtree</a> (<a class="el" href="classagentxcpp_1_1oid.html">oid</a> subtree, uint8_t priority=127, uint8_t timeout=0)</td></tr>
<tr class="memdesc:a6c6a57de2c3f38721d44663e0bf34651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a subtree with the master agent.  <a href="#a6c6a57de2c3f38721d44663e0bf34651"></a><br/></td></tr>
<tr class="memitem:a19c5b70a4ba2deb4b69abee94b07da31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1master__proxy.html#a19c5b70a4ba2deb4b69abee94b07da31">unregister_subtree</a> (<a class="el" href="classagentxcpp_1_1oid.html">oid</a> subtree, uint8_t priority=127)</td></tr>
<tr class="memdesc:a19c5b70a4ba2deb4b69abee94b07da31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a subtree with the master agent.  <a href="#a19c5b70a4ba2deb4b69abee94b07da31"></a><br/></td></tr>
<tr class="memitem:a2f96086f345009189bd68135c55c7ba2"><td class="memItemLeft" align="right" valign="top">boost::asio::io_service *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1master__proxy.html#a2f96086f345009189bd68135c55c7ba2">get_io_service</a> () const </td></tr>
<tr class="memdesc:a2f96086f345009189bd68135c55c7ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the io_service object used by this <a class="el" href="classagentxcpp_1_1master__proxy.html" title="This class represents the master agent in a subagent program.">master_proxy</a>.  <a href="#a2f96086f345009189bd68135c55c7ba2"></a><br/></td></tr>
<tr class="memitem:a9a92916553e334f3675e430e9848ecf9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1master__proxy.html#a9a92916553e334f3675e430e9848ecf9">is_connected</a> ()</td></tr>
<tr class="memdesc:a9a92916553e334f3675e430e9848ecf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the session is in state connected.  <a href="#a9a92916553e334f3675e430e9848ecf9"></a><br/></td></tr>
<tr class="memitem:a25f794f0abc4b988f7e3f2be4735160c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1master__proxy.html#a25f794f0abc4b988f7e3f2be4735160c">connect</a> ()</td></tr>
<tr class="memdesc:a25f794f0abc4b988f7e3f2be4735160c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to the master agent.  <a href="#a25f794f0abc4b988f7e3f2be4735160c"></a><br/></td></tr>
<tr class="memitem:a8894319cc158a911034c155d5533a51d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1master__proxy.html#a8894319cc158a911034c155d5533a51d">disconnect</a> (ClosePDU::reason_t reason=ClosePDU::reasonShutdown)</td></tr>
<tr class="memdesc:a8894319cc158a911034c155d5533a51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdown the session.  <a href="#a8894319cc158a911034c155d5533a51d"></a><br/></td></tr>
<tr class="memitem:a84db5e9df0926eae5938b95cb056c120"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1master__proxy.html#a84db5e9df0926eae5938b95cb056c120">reconnect</a> ()</td></tr>
<tr class="memdesc:a84db5e9df0926eae5938b95cb056c120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconnect to the master agent.  <a href="#a84db5e9df0926eae5938b95cb056c120"></a><br/></td></tr>
<tr class="memitem:ac06f0f9a1d0704dfbaac72d64b87d4d8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1master__proxy.html#ac06f0f9a1d0704dfbaac72d64b87d4d8">get_sessionID</a> ()</td></tr>
<tr class="memdesc:ac06f0f9a1d0704dfbaac72d64b87d4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sessionID of the session.  <a href="#ac06f0f9a1d0704dfbaac72d64b87d4d8"></a><br/></td></tr>
<tr class="memitem:af162b86b6cb98933921c830d923b598e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1master__proxy.html#af162b86b6cb98933921c830d923b598e">~master_proxy</a> ()</td></tr>
<tr class="memdesc:af162b86b6cb98933921c830d923b598e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#af162b86b6cb98933921c830d923b598e"></a><br/></td></tr>
<tr class="memitem:a1f212d2c8f6808888a98fff9d8d1f8aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1master__proxy.html#a1f212d2c8f6808888a98fff9d8d1f8aa">add_variable</a> (const <a class="el" href="classagentxcpp_1_1oid.html">oid</a> &amp;id, shared_ptr&lt; <a class="el" href="classagentxcpp_1_1variable.html">variable</a> &gt; v)</td></tr>
<tr class="memdesc:a1f212d2c8f6808888a98fff9d8d1f8aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an SNMP variable for serving.  <a href="#a1f212d2c8f6808888a98fff9d8d1f8aa"></a><br/></td></tr>
<tr class="memitem:a9395c0cbe7d3cf7b07c6a104cfc468de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1master__proxy.html#a9395c0cbe7d3cf7b07c6a104cfc468de">remove_variable</a> (const <a class="el" href="classagentxcpp_1_1oid.html">oid</a> &amp;id)</td></tr>
<tr class="memdesc:a9395c0cbe7d3cf7b07c6a104cfc468de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an SNMP variable so that is not longer accessible.  <a href="#a9395c0cbe7d3cf7b07c6a104cfc468de"></a><br/></td></tr>
<tr class="inherit_header pub_methods_classagentxcpp_1_1connector_1_1pdu__handler"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classagentxcpp_1_1connector_1_1pdu__handler')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="classagentxcpp_1_1connector_1_1pdu__handler.html">agentxcpp::connector::pdu_handler</a></td></tr>
<tr class="memitem:a2b445c92b77793696b615373a3f521f5 inherit pub_methods_classagentxcpp_1_1connector_1_1pdu__handler"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>handle_pdu</b> (boost::shared_ptr&lt; PDU &gt; pdu, int error)=0</td></tr>
<tr class="memdesc:a2b445c92b77793696b615373a3f521f5 inherit pub_methods_classagentxcpp_1_1connector_1_1pdu__handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler method for incoming PDU's.  <a href="#a2b445c92b77793696b615373a3f521f5"></a><br/></td></tr>
<tr class="memitem:a5adbc6e6a7686c35af07387a141f8120 inherit pub_methods_classagentxcpp_1_1connector_1_1pdu__handler"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~pdu_handler</b> ()</td></tr>
<tr class="memdesc:a5adbc6e6a7686c35af07387a141f8120 inherit pub_methods_classagentxcpp_1_1connector_1_1pdu__handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a5adbc6e6a7686c35af07387a141f8120"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This class represents the master agent in a subagent program. </p>
<dl class="section user"><dt>Introduction</dt><dd></dd></dl>
<p>This class is used on the subagent's side of a connection between subagent and master agent. It serves as a proxy which represents the master agent. It is possible for a subagent to hold connections to more than one master agents. For each connection one <a class="el" href="classagentxcpp_1_1master__proxy.html" title="This class represents the master agent in a subagent program.">master_proxy</a> object is created. Multiple connections to the same master agent are possible, too, in which case one <a class="el" href="classagentxcpp_1_1master__proxy.html" title="This class represents the master agent in a subagent program.">master_proxy</a> per connection is needed. </p>
<dl class="section user"><dt>Connection State</dt><dd></dd></dl>
<p>The <a class="el" href="classagentxcpp_1_1master__proxy.html" title="This class represents the master agent in a subagent program.">master_proxy</a> is always in one of the following states:</p>
<ol type="1">
<li>connected</li>
<li>disconnected</li>
</ol>
<p>The session to the master agent is established when creating a <a class="el" href="classagentxcpp_1_1master__proxy.html" title="This class represents the master agent in a subagent program.">master_proxy</a> object, thus the object usually starts in connected state. If that fails, the object starts in disconnected state. A connected <a class="el" href="classagentxcpp_1_1master__proxy.html" title="This class represents the master agent in a subagent program.">master_proxy</a> object may also loose the connection to the master agent and consequently become disconnected, without informing the user. It is possible to re-connect with the <a class="el" href="classagentxcpp_1_1master__proxy.html#a84db5e9df0926eae5938b95cb056c120" title="Reconnect to the master agent.">reconnect()</a> function at any time (even if the session is currently established - it will be shut down and re-established in this case). When the object is destroyed, the session will be cleanly shut down. The connection state can be inspected with the <a class="el" href="classagentxcpp_1_1master__proxy.html#a9a92916553e334f3675e430e9848ecf9" title="Check whether the session is in state connected.">is_connected()</a> function. Some functions throw a disconnected exception if the session is not currently established. </p>
<dl class="section user"><dt>The io_service object</dt><dd></dd></dl>
<p>The <a class="el" href="classagentxcpp_1_1master__proxy.html" title="This class represents the master agent in a subagent program.">master_proxy</a> class uses the boost::asio library for networking and therefore needs a boost::asio::io_service object. This object can either be provided by the user or created automatically. There are two constructors available therefore. The used object (whether auto-created or not) can be obtained using the <a class="el" href="classagentxcpp_1_1master__proxy.html#a2f96086f345009189bd68135c55c7ba2" title="Get the io_service object used by this master_proxy.">get_io_service()</a> function. If the io_service object was autocreated by a constructor, it will be destroyed by the destructor. If the user provided the io_service, it will NOT be destroyed by the destructor. It is possible to create multiple <a class="el" href="classagentxcpp_1_1master__proxy.html" title="This class represents the master agent in a subagent program.">master_proxy</a> objects using the same io_service object, or using different io_service objects.</p>
<p>Receiving data from the master agent is done asynchronously and only works if io_service::run() or io_service::run_one() is invoked. However, some operations (such as registering stuff) invoke io_service::run_one() several times while waiting for a response from the master agent. If the io_service object is not used exclusively by the <a class="el" href="classagentxcpp_1_1master__proxy.html" title="This class represents the master agent in a subagent program.">master_proxy</a> object (which is entirely possible), this may complete asynchronous events before the library operation (e.g. registering) is completed. Even the internal asynchronous reception calls io_service::run_one() while waiting for more data. If this behaviour is not desired, a separate io_service object should be used for other asynchronous I/O operations. </p>
<dl class="section user"><dt>Registrations</dt><dd></dd></dl>
<p>Before the master agent sends requests to a subagent, the subagent must register a subtree. Doing so informs the master agent that the subagent wishes to handle requests for these OIDs. A subtree is an OID which denotes the root of a subtree in which some of the offered objects resides. For example, when two objects shall be offered with the OIDs 1.3.6.1.4.1.42<b>.1.1</b> and 1.3.6.1.4.1.42<b>.1.2</b>, then a subtree with OID 1.3.6.1.4.1.42<b>.1</b> should be registered, which includes both objects. The master agent will then forward all requests conecerning objects in this subtree to this subagent. Requests to non-existing objects (e.g. 1.3.6.1.4.1.42<b>.1.3</b>) are also forwarded, and the agentXcpp library will take care of them and return an appropriate error to the master agent.</p>
<p>The function <a class="el" href="classagentxcpp_1_1master__proxy.html#a6c6a57de2c3f38721d44663e0bf34651" title="Register a subtree with the master agent.">register_subtree()</a> is used to register a subtree. It is typically called for the highest-level OID of the MIB which is implemented by the subagent. However, it is entirely possible to register multiple subtrees.</p>
<p>Identical subtrees are subtrees with the exact same root OID. Each registration is done with a priority value. The higher the value, the lower the priority. When identical subtrees are registered (by the same subagent or by different subagents), the priority value is used to decide which subagent gets the requests. The master refuses identical registrations with the same priority values. Note however, that in case of overlapping subtrees which are <em>not</em> identical (e.g. 1.3.6.1.4.1.42<b>.1</b> and 1.3.6.1.4.1.42<b>.1.33.1</b>), the most specific subtree (i.e. the one with the longest OID) wins regardless of the priority values.</p>
<p>It is also possible to unregister subtrees using the <a class="el" href="classagentxcpp_1_1master__proxy.html#a19c5b70a4ba2deb4b69abee94b07da31" title="Unregister a subtree with the master agent.">unregister_subtree()</a> function. This informs the master agent that the MIB region is no longer available from this subagent. </p>
<dl class="section user"><dt>Adding and Removing Variables</dt><dd></dd></dl>
<p>Registering a subtree does not make any SNMP variables accessible yet. To provide SNMP variables, they must be added to the <a class="el" href="classagentxcpp_1_1master__proxy.html" title="This class represents the master agent in a subagent program.">master_proxy</a> object, e.g. using <a class="el" href="classagentxcpp_1_1master__proxy.html#a1f212d2c8f6808888a98fff9d8d1f8aa" title="Add an SNMP variable for serving.">add_variable()</a>. The <a class="el" href="classagentxcpp_1_1master__proxy.html" title="This class represents the master agent in a subagent program.">master_proxy</a> object will then dispatch incoming requests to the variables it knows about. If a request is received for an OID for which no variable has been added, an appropriate error is returned to the master agent.</p>
<p>Added variables can be removed again using <a class="el" href="classagentxcpp_1_1master__proxy.html#a9395c0cbe7d3cf7b07c6a104cfc468de" title="Remove an SNMP variable so that is not longer accessible.">remove_variable()</a>. This makes a variable inaccessible for the master agent. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af6d8fdc6474185183a155b2bd6dc70fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">master_proxy::master_proxy </td>
          <td>(</td>
          <td class="paramtype">boost::asio::io_service *&#160;</td>
          <td class="paramname"><em>io_service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>description</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>default_timeout</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classagentxcpp_1_1oid.html">oid</a>&#160;</td>
          <td class="paramname"><em>ID</em> = <code><a class="el" href="classagentxcpp_1_1oid.html">oid</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>unix_domain_socket</em> = <code>&quot;/var/agentx/master&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a session object connected via unix domain socket. </p>
<p>This constructor tries to connect to the master agent. If that fails, the object is created nevertheless and will be in state disconnected.</p>
<p>This constructor takes an io_service object as parameter. The io_service is not destroyed by the constructor.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_service</td><td>The io_service object.</td></tr>
    <tr><td class="paramname">description</td><td>A string describing the subagent. This description cannot be changed later.</td></tr>
    <tr><td class="paramname">default_timeout</td><td>The length of time, in seconds, that the master agent should allow to elapse before it regards the subagent as not responding. The value is also used when waiting synchronously for data from the master agent (e.g. when registering stuff). Allowed values are 0-255, with 0 meaning "no default for this session".</td></tr>
    <tr><td class="paramname">ID</td><td>An Object Identifier that identifies the subagent. Default is the null OID (no ID).</td></tr>
    <tr><td class="paramname">unix_domain_socket</td><td>The socket file to connect to. Defaults to /var/agentx/master, as desribed in RFC 2741, section 8.2.1 "Well-known Values". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aca2d85c52b5be12bf5a25301f4014c4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">master_proxy::master_proxy </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>description</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>default_timeout</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classagentxcpp_1_1oid.html">oid</a>&#160;</td>
          <td class="paramname"><em>ID</em> = <code><a class="el" href="classagentxcpp_1_1oid.html">oid</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>unix_domain_socket</em> = <code>&quot;/var/agentx/master&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a session object connected via unix domain socket. </p>
<p>This constructor tries to connect to the master agent. If that fails, the object is created nevertheless and will be in state disconnected.</p>
<p>This constructor creates an io_service object which is destroyed by the desctructor.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">description</td><td>A string describing the subagent. This description cannot be changed later.</td></tr>
    <tr><td class="paramname">default_timeout</td><td>The length of time, in seconds, that the master agent should allow to elapse before it regards the subagent as not responding. The value is also used when waiting synchronously for data from the master agent (e.g. when registering stuff). Allowed values are 0-255, with 0 meaning "no default for this session".</td></tr>
    <tr><td class="paramname">ID</td><td>An Object Identifier that identifies the subagent. Default is the null OID (no ID).</td></tr>
    <tr><td class="paramname">unix_domain_socket</td><td>The socket file to connect to. Defaults to /var/agentx/master, as desribed in RFC 2741, section 8.2.1 "Well-known Values". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af162b86b6cb98933921c830d923b598e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">master_proxy::~master_proxy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>The destructor cleanly shuts down the session with the reason 'Shutdown' (if it is currently established) and destroys the <a class="el" href="classagentxcpp_1_1master__proxy.html" title="This class represents the master agent in a subagent program.">master_proxy</a> object. It also destroys the io_service object if it was created automatically (i.e. not provided by the user). </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a1f212d2c8f6808888a98fff9d8d1f8aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void master_proxy::add_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classagentxcpp_1_1oid.html">oid</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">shared_ptr&lt; <a class="el" href="classagentxcpp_1_1variable.html">variable</a> &gt;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an SNMP variable for serving. </p>
<p>This adds an SNMP variable which can then be read and/or written.</p>
<p>Variables can only be added to MIB regions which were registered in advance.</p>
<p>If adding a variable with an id for which another variable is already registered, it replaces the odl one.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The OID of the variable.</td></tr>
    <tr><td class="paramname">v</td><td>The variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classagentxcpp_1_1unknown__registration.html" title="Exception to indicate that a MIB region registration was not found.">unknown_registration</a></td><td>If trying to add a variable with an id which does not reside within a registered MIB region. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25f794f0abc4b988f7e3f2be4735160c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void master_proxy::connect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect to the master agent. </p>
<dl class="section note"><dt>Note:</dt><dd>Upon creation of a session object, the connection is automatically established. If the current state is "connected", the function does nothing.</dd></dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname">disconnected</td><td>If connecting fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8894319cc158a911034c155d5533a51d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void master_proxy::disconnect </td>
          <td>(</td>
          <td class="paramtype">ClosePDU::reason_t&#160;</td>
          <td class="paramname"><em>reason</em> = <code>ClosePDU::reasonShutdown</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shutdown the session. </p>
<p>Disconnect from the master agent.</p>
<dl class="section note"><dt>Note:</dt><dd>Upon destruction of a session object the session is automatically shutdown. If the session is in state "disconnected", this function does nothing.</dd></dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">reason</td><td>The shutdown reason is reported to the master agent during shutdown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f96086f345009189bd68135c55c7ba2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::asio::io_service* agentxcpp::master_proxy::get_io_service </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the io_service object used by this <a class="el" href="classagentxcpp_1_1master__proxy.html" title="This class represents the master agent in a subagent program.">master_proxy</a>. </p>

</div>
</div>
<a class="anchor" id="ac06f0f9a1d0704dfbaac72d64b87d4d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t agentxcpp::master_proxy::get_sessionID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the sessionID of the session. </p>
<p>Get the session ID of the last established session, even if the current state is "disconnected".</p>
<dl class="section return"><dt>Returns:</dt><dd>The session ID of the last established session. If object was never connected to the master, 0 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a92916553e334f3675e430e9848ecf9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool agentxcpp::master_proxy::is_connected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the session is in state connected. </p>
<dl class="section return"><dt>Returns:</dt><dd>true if the session is connected, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a84db5e9df0926eae5938b95cb056c120"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void agentxcpp::master_proxy::reconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconnect to the master agent. </p>
<p>Disconnects from the master (only if currently connected), then connects again.</p>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname">disconnected</td><td>If connecting fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c6a57de2c3f38721d44663e0bf34651"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void master_proxy::register_subtree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classagentxcpp_1_1oid.html">oid</a>&#160;</td>
          <td class="paramname"><em>subtree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priority</em> = <code>127</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a subtree with the master agent. </p>
<p>This function registers a subtree (or MIB region).</p>
<pre class="fragment">           \param subtree The (root of the) subtree to register.

           \param priority The priority with which to register the subtree.
                           Default is 127 according to RFC 2741, 6.2.3.  
                           "The agentx-Register-PDU".

           \param timeout The timeout value for the registered subtree, in
                          seconds. This value overrides the timeout of the 
                          session.  Default value is 0 (no override) 
                          according to RFC 2741, 6.2.3.  "The 
                          agentx-Register-PDU".

           \exception disconnected If the master_proxy is currently in
                                   state 'disconnected'.

           \exception timeout_exception If the master agent does not
                                        respond within the timeout 
                                        interval.

           \exception master_is_unable The master agent was unable to
                                       perform the desired register 
                                       request.  The reason for that is 
                                       unknown.

           \exception duplicate_registration If the exact same subtree was
                                             alread registered, either by 
                                             another subagent or by this 
                                             subagent.

           \exception master_is_unwilling If the master was unwilling for
                                          some reason to make the desired 
                                          registration.

           \exception parse_error A malformed network message was found
                                  during communcation with the master. This 
                                  may be a programming error in the master 
                                  or in the agentXcpp library. It is 
                                  possible that the master actually 
                                  performed the desired registration and 
                                  that a retry will result in a 
                                  duplicate_registration error.

           \note This function invokes run_one() one or more times on the
                 io_service object.</pre> 
</div>
</div>
<a class="anchor" id="a9395c0cbe7d3cf7b07c6a104cfc468de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void master_proxy::remove_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classagentxcpp_1_1oid.html">oid</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an SNMP variable so that is not longer accessible. </p>
<p>This removes a variable previously added using <a class="el" href="classagentxcpp_1_1master__proxy.html#a1f212d2c8f6808888a98fff9d8d1f8aa" title="Add an SNMP variable for serving.">add_variable()</a>. The variable will no longer receive SNMP requests.</p>
<p>If no variable is known for the given id, nothing happens.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The OID of the variable to remove. This is the OID which was given to <a class="el" href="classagentxcpp_1_1master__proxy.html#a1f212d2c8f6808888a98fff9d8d1f8aa" title="Add an SNMP variable for serving.">add_variable()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a19c5b70a4ba2deb4b69abee94b07da31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void master_proxy::unregister_subtree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classagentxcpp_1_1oid.html">oid</a>&#160;</td>
          <td class="paramname"><em>subtree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priority</em> = <code>127</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister a subtree with the master agent. </p>
<p>This function unregisters a subtree (or MIB region) which has previously been registered.</p>
<pre class="fragment">           \param subtree The (root of the) subtree to unregister.

           \param priority The priority with which the registration was
                           done.

           \exception disconnected If the master_proxy is currently in
                                   state 'disconnected'.

           \exception timeout_error If the master agent does not
                                    respond within the timeout interval.

           \exception master_is_unable The master agent was unable to
                                       perform the desired unregister 
                                       request.  The reason for that is 
                                       unknown.

           \exception unknown_registration The MIB region is not currently
                                           registered with this parameters.

           \exception parse_error A malformed network message was found
                                  during communcation with the master. This 
                                  may be a programming error in the master 
                                  or in the agentXcpp library. It is 
                                  possible that the master actually 
                                  unregistered the MIB region.

           \note This function invokes run_one() one or more times on the
                 io_service object.</pre> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>agentxcpp</b></li><li class="navelem"><a class="el" href="classagentxcpp_1_1master__proxy.html">master_proxy</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

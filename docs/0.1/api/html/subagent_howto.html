<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>AgentXcpp: How to write a Subagent</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">AgentXcpp
   &#160;<span id="projectnumber">Revision:0.1</span>
   </div>
   <div id="projectbrief">API Documentation</div>
  </td>
  
  
  
   
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('subagent_howto.html','');
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">How to write a Subagent </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section note"><dt>Note:</dt><dd>It is assumed that agentXcpp is installed properly; see <a class="el" href="installation.html">Building and Installing AgentXcpp</a> for how to do that.</dd></dl>
<p>This HOWTO explains how to implement, compile and run a trivial subagent. Our trivial subagent has only one variable called 'simpleCounter' which is described within the minimal MIB called 'SIMPLE-MIB':</p>
<div class="fragment"><pre class="fragment">SIMPLE-MIB DEFINITIONS ::= BEGIN

IMPORTS OBJECT-TYPE FROM SNMPv2-SMI

simpleCounter OBJECT-TYPE
    SYNTAX INTEGER
    ACCESS read-only
    STATUS mandatory
    DESCRIPTION "A simple counter which is incremented each time
                 it is queried. Starts with 0."
    ::={ enterprises 42 1 }

END
</pre></div><p>Now let's see how easy this can be implemented with agentXcpp!</p>
<h2><a class="anchor" id="implementing"></a>
Implementing the Subagent</h2>
<h3><a class="anchor" id="headers"></a>
The Headers</h3>
<p>First of all, we need to include some header files for our subagent:</p>
<div class="fragment"><pre class="fragment"><span class="comment">// Make the class agentxcpp::Integer available:</span>
<span class="preprocessor">#include &lt;agentxcpp/Integer.hpp&gt;</span>

<span class="comment">// Make the class agentxcpp::master_proxy available:</span>
<span class="preprocessor">#include &lt;agentxcpp/master_proxy.hpp&gt;</span>

<span class="comment">// We want to output error messages:</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
</pre></div><p>All agentXcpp classes are in the namespace 'agentxcpp'. To make the code more readable, we make the namespace globally available:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">using namespace </span>agentxcpp;
</pre></div><h3><a class="anchor" id="implement_class"></a>
Implementing the simpleCounter Variable</h3>
<p>The simpleCounter thing described above is an OBJECT-TYPE. OBJECT-TYPE is a description of the object, not the object itself. The OID of simpleCounter is "enterprises.42.1", while the real object will be accessible with OID "enterprises.42.1.0".</p>
<p>In C++, objects are described by their classes (note the difference between classes and objects). The class-object-relation in C++ is similar to the "OBJECT-TYPE"-"object"-relation in SNMP. Therefore, OBJEC-TYPEs are represented by classes in agentXcpp, while SNMP objects are represented by C++ objects. Therefore, to implement simpleCounter, we start with a class (later we will make an object of the class):</p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>simpleCounter : <span class="keyword">public</span> Integer
{
</pre></div><p>The simpleCounter has a type which is given in the SYNTAX clause in the MIB. AgentXcpp provides various classes to match standard SYNTAX types, all of which inherit from the <a class="el" href="classagentxcpp_1_1variable.html">variable</a> class. Our simpleCounter class inherits from <a class="el" href="classagentxcpp_1_1_integer.html">Integer</a>, which makes it an INTEGER.</p>
<p>Next, the get() method from <a class="el" href="classagentxcpp_1_1_integer.html">Integer</a> must be overridden. This method is called on SNMP GET requests and returns the current value of the object. In our case, it returns the value of a member variable and increments this variable afterwards:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">private</span>:
        int32_t counter;

    <span class="keyword">public</span>:
        <span class="keyword">virtual</span> int32_t <span class="keyword">get</span>()
        {
            <span class="keywordflow">return</span> counter++;
        }
</pre></div><p>Finally, we add a constructor which initializes the 'counter' member to zero:</p>
<div class="fragment"><pre class="fragment">        simpleCounter()
          : counter(0)
        {
        }
};
</pre></div><h3><a class="anchor" id="main_function"></a>
The main() Function</h3>
<p>In the main() function, we create a master_proxy object:</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
{
    master_proxy master;
</pre></div><p>The class <a class="el" href="classagentxcpp_1_1master__proxy.html">master_proxy</a> is used to communicate with the master agent. A master_proxy can be thought of a local C++ object representing the remote master agent. The master_proxy can be in disconnected state at any time, or become disconnected, which means that most operations could possibly fail with a <a class="el" href="classagentxcpp_1_1disconnected.html" title="Exception to indicate a disconnected state.">agentxcpp::disconnected</a> exception.</p>
<p>The default constructor of <a class="el" href="classagentxcpp_1_1master__proxy.html">master_proxy</a> tries to connect to the master agent via the unix domain socket <code>/var/agentx/master</code>. Of course, another unix domain socket may be chosen, but it cannot be changed once the master_proxy object is created.</p>
<p>Now, as we have the <a class="el" href="classagentxcpp_1_1master__proxy.html">master_proxy</a> object, we register a subtree. This means that we provide an OID to the master to indicate that our subagent wishes to serve all requests to OIDs starting with that OID. For our subagent we use "enterprises.42.1", where 'enterprises' is the standard OID "1.3.6.1.4.1". The master will then send all SNMP requests within that subtree to our subagent (e.g. "enterprises.42.1.0" or "enterprises.42.1.1.2.0"), regardless of whether the subagent actually can serve them. If a request cannot be served, the <a class="el" href="classagentxcpp_1_1master__proxy.html">master_proxy</a> will send an appropriate error message to the master agent.</p>
<p>And here is the code for subtree registration:</p>
<div class="fragment"><pre class="fragment">    oid simpleagent_oid = oid(<a class="code" href="classagentxcpp_1_1oid.html#a896156dc5599d691dc3edc6baf763d4e" title="The &#39;iso.org.dod.internet.private.enterprises&#39; OID according to RFC 1155.">enterprises_oid</a>, <span class="stringliteral">&quot;42.1&quot;</span>);
    master.register_subtree(simpleagent_oid);
</pre></div><p>As you see, an <a class="el" href="classagentxcpp_1_1oid.html">oid</a> object can be created by giving it the "enterprises_oid" object (which is provided by agentXcpp for convenience) and an additional string with further subids.</p>
<p>Next, we create a simpleCounter variable and register it with agentXcpp:</p>
<div class="fragment"><pre class="fragment">    oid simpleCounter_oid(simpleagent_oid, <span class="stringliteral">&quot;0&quot;</span>);
    shared_ptr&lt;simpleCounter&gt; sc(<span class="keyword">new</span> simpleCounter);
    master.add_variable( simpleCounter_oid, sc);
</pre></div><p>This is the place where we create the real SNMP variable 'sc'. This variable is then registered with the master agent by providing its OID (the one with .0) and the object itself. Note that the object is given in form of a shared pointer, which means that is must be created using the 'new' operator.</p>
<p>Finally we give control to the agentXcpp library in order to receive requests from the master agent:</p>
<div class="fragment"><pre class="fragment">    <span class="keywordflow">while</span>( master.is_connected() )
    {
        master.get_io_service()-&gt;run();
    }

    std::cerr &lt;&lt; <span class="stringliteral">&quot;I lost the connection to the master agent.&quot;</span> &lt;&lt; std::endl;
}
</pre></div><p>The <a class="el" href="classagentxcpp_1_1master__proxy.html">master_proxy</a> uses boost::asio for networking, therefore a boost::asio::io_service object is utilized to give control to boost::asio, which in turn informs agentXcpp about incoming data. If you plan to use boost::asio in your real subagent, you can integrate with agentXcpp. For example, you can use the same boost::asio::io_service object as the master_proxy, or tell the master_proxy to use a boost::asio::io_service object that you provide.</p>
<p>The main loop is left if the 'master' object ever gets disconnected. In this case, an error message is output, and the subagent exits. A real subagent might try to reconnect to the master agent with <code>master.reconnect()</code>.</p>
<p>If the connection fails earlier (e.g. upon creation of the 'master' object), exceptions are thrown by the <code>master.register_subtree()</code> or <code>master.add_variable()</code> calls, which will abort the subagent. This should be fine for the first time; a more realistic subagent should of course handle exceptions properly.</p>
<p>Now, let's store the program as <code>simpleagent.cpp</code> and compile it!</p>
<h2><a class="anchor" id="compiling"></a>
Compiling the Subagent</h2>
<p>When compiling the subagent, we need to link against the boost library 'system_error', 'pthread' and, of course, against the agentXcpp library. In linux, you can type the following command:</p>
<div class="fragment"><pre class="fragment">g++ simpleagent.cpp -o simpleagent -lboost_system -lpthread -lagentxcpp
</pre></div><p>This assumes that the agentxcpp library is installed properly, so that the compiler can find the headers and the shared object file.</p>
<h2><a class="anchor" id="running"></a>
Running the Subagent</h2>
<p>This step is difficult to describe, because it depends on your setup how to get the subagent running. This howto describes the procedure using the NET-SNMP package on linux. That package contains a daemon which can be used as master agent, and some command line tools, which can be used to query the SNMP agent.</p>
<p>We will configure the NET-SNMP agent to act as AgentX master agent. To keep this guide simple, we will use the SNMPv1 protocol using "rw" as read-write community name, but our subagent can of course be queried using SNMPv2c or SNMPv3, as long as the master is configured accordingly. The subagent implementation is independent of the used SNMP version.</p>
<h3><a class="anchor" id="starting_master"></a>
Starting the master agent</h3>
<p>First, we add the following lines to its config file <code>/etc/snmp/snmpd.conf</code>:</p>
<div class="fragment"><pre class="fragment">rwcommunity rw        # use "rw" as read-write-community name
master      agentx    # snmpd shall act as agentX master agent
agentXPerms 0666 777  # make socket world-readable
</pre></div><p>The community name is needed later, when issuing a SNMP GET request. We set it to "rw" in the example, but you can use anything you wish.</p>
<p>The agentXPerms are not strictly required, but making the socket world-readable saves us some trouble regarding access restrictions. Next, we (re)start the master agent using its init scripts:</p>
<div class="fragment"><pre class="fragment">/etc/init.d/snmpd stop
/etc/init.d/snmpd start
</pre></div><p>Note that the path depends on your system. For example in ArchLinux, it is /etc/rc.d/snmpd.</p>
<h3><a class="anchor" id="starting_subagent"></a>
Starting the Subagent</h3>
<p>Now the subagent can be started:</p>
<div class="fragment"><pre class="fragment">./simpleagent
</pre></div><p>If the subagent can't connect to the master, or another error is detected, it will terminate with an exception (since our code doesn't catch any exceptions). Or, if connection is lost, it will leave the main loop and exit with the error message we implemented.</p>
<p>Otherwise, the subagent is now connected, and we can try if it works.</p>
<h3><a class="anchor" id="querying"></a>
Querying the Subagent</h3>
<p>Our little subagent exposes an INTERGER object with the OID "1.3.6.1.4.1.42.1.0". We can query this object with an SNMP GET request. We use the NET-SNMP utility snmpget (but you can use any tool you wish, of course):</p>
<div class="fragment"><pre class="fragment">snmpget -v1 -c rw localhost 1.3.6.1.4.1.42.1.0
</pre></div><p>Or, if the MIB above is put into a file in the right directory, we can also do:</p>
<div class="fragment"><pre class="fragment">snmpget -v1 -c rw localhost enterprises.42.1.0
</pre></div><p>Each time the command is executed, the simpleCounter object reports the incremented number. The trivial subagent is working now, your installation have proven to be usable, thus you can go and implement your own subagent! </p>
</div></div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.0 </li>
   </ul>
 </div>


</body>
</html>

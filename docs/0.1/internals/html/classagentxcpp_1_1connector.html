<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>AgentXcpp: agentxcpp::connector Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">AgentXcpp
   &#160;<span id="projectnumber">Revision:0.1</span>
   </div>
   <div id="projectbrief">Internals Documentation</div>
  </td>
  
  
  
   
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classagentxcpp_1_1connector.html','');
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">agentxcpp::connector Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class provides connection to another agentXcpp entity via a unix domain socket.  
 <a href="classagentxcpp_1_1connector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="connector_8hpp_source.html">connector.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for agentxcpp::connector:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classagentxcpp_1_1connector__coll__graph.svg" width="683" height="438"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classagentxcpp_1_1connector-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1connector_1_1pdu__handler.html">pdu_handler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for classes which can handle incoming <a class="el" href="classagentxcpp_1_1_p_d_u.html" title="The base class of all PDU&#39;s.">PDU</a>'s.  <a href="classagentxcpp_1_1connector_1_1pdu__handler.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac66b42853b9dd85f3c2b7ee9a0e6bc39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1connector.html#ac66b42853b9dd85f3c2b7ee9a0e6bc39">connector</a> (boost::shared_ptr&lt; boost::asio::io_service &gt; <a class="el" href="classagentxcpp_1_1connector.html#a44295925e0bd5f76ac8183fad30d58fc">io_service</a>, const std::string &amp;unix_domain_socket, unsigned <a class="el" href="classagentxcpp_1_1connector.html#ad333ffb80e2359241c86364fa8be8a96">timeout</a>)</td></tr>
<tr class="memdesc:ac66b42853b9dd85f3c2b7ee9a0e6bc39"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor.  <a href="#ac66b42853b9dd85f3c2b7ee9a0e6bc39"></a><br/></td></tr>
<tr class="memitem:a9b4effeb519301d589e11fe2914c1f09"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="classagentxcpp_1_1_response_p_d_u.html">ResponsePDU</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1connector.html#a9b4effeb519301d589e11fe2914c1f09">wait_for_response</a> (<a class="el" href="types_8hpp.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> packetID)</td></tr>
<tr class="memdesc:a9b4effeb519301d589e11fe2914c1f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait with timeout for a reponse.  <a href="#a9b4effeb519301d589e11fe2914c1f09"></a><br/></td></tr>
<tr class="memitem:ad4be113f201584ce0fd15d24d4929def"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1connector.html#ad4be113f201584ce0fd15d24d4929def">register_handler</a> (<a class="el" href="classagentxcpp_1_1connector_1_1pdu__handler.html">pdu_handler</a> *<a class="el" href="classagentxcpp_1_1connector.html#afe1f4f84618fef58cd0065847498aa24">handler</a>)</td></tr>
<tr class="memdesc:ad4be113f201584ce0fd15d24d4929def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a handler object for received PDU's.  <a href="#ad4be113f201584ce0fd15d24d4929def"></a><br/></td></tr>
<tr class="memitem:a0d5c81d1908b7db51d1080453dd5289b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1connector.html#a0d5c81d1908b7db51d1080453dd5289b">connect</a> ()</td></tr>
<tr class="memdesc:a0d5c81d1908b7db51d1080453dd5289b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to the remote entity.  <a href="#a0d5c81d1908b7db51d1080453dd5289b"></a><br/></td></tr>
<tr class="memitem:ae402d364dfc5b6a1f794256cb2823a0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1connector.html#ae402d364dfc5b6a1f794256cb2823a0d">disconnect</a> ()</td></tr>
<tr class="memdesc:ae402d364dfc5b6a1f794256cb2823a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect the remote entity.  <a href="#ae402d364dfc5b6a1f794256cb2823a0d"></a><br/></td></tr>
<tr class="memitem:ae2de68485ec32d9f944266d6ffb3003e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1connector.html#ae2de68485ec32d9f944266d6ffb3003e">is_connected</a> ()</td></tr>
<tr class="memdesc:ae2de68485ec32d9f944266d6ffb3003e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out whether the object is currently connected.  <a href="#ae2de68485ec32d9f944266d6ffb3003e"></a><br/></td></tr>
<tr class="memitem:a4f59919d2c688e62111133a927ed190c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1connector.html#a4f59919d2c688e62111133a927ed190c">send</a> (const <a class="el" href="classagentxcpp_1_1_p_d_u.html">PDU</a> &amp;pdu)</td></tr>
<tr class="memdesc:a4f59919d2c688e62111133a927ed190c"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a PDU to the remote entity.  <a href="#a4f59919d2c688e62111133a927ed190c"></a><br/></td></tr>
<tr class="memitem:a2b10934a5124edc0f78453c50fe36884"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1connector.html#a2b10934a5124edc0f78453c50fe36884">~connector</a> ()</td></tr>
<tr class="memdesc:a2b10934a5124edc0f78453c50fe36884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a2b10934a5124edc0f78453c50fe36884"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a84511fbf6e1a62c1dfcdba8da7c40c81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1connector.html#a84511fbf6e1a62c1dfcdba8da7c40c81">receive_callback</a> (const boost::system::error_code &amp;result)</td></tr>
<tr class="memdesc:a84511fbf6e1a62c1dfcdba8da7c40c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function to receive a PDU.  <a href="#a84511fbf6e1a62c1dfcdba8da7c40c81"></a><br/></td></tr>
<tr class="memitem:a9b1d09d8700ee2b15c38644a65d259b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1connector.html#a9b1d09d8700ee2b15c38644a65d259b3">connector</a> ()</td></tr>
<tr class="memdesc:a9b1d09d8700ee2b15c38644a65d259b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hide standard constructor.  <a href="#a9b1d09d8700ee2b15c38644a65d259b3"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ad333ffb80e2359241c86364fa8be8a96"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1connector.html#ad333ffb80e2359241c86364fa8be8a96">timeout</a></td></tr>
<tr class="memdesc:ad333ffb80e2359241c86364fa8be8a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">The timeout in milliseconds, used in various contexts.  <a href="#ad333ffb80e2359241c86364fa8be8a96"></a><br/></td></tr>
<tr class="memitem:a44295925e0bd5f76ac8183fad30d58fc"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr<br class="typebreak"/>
&lt; boost::asio::io_service &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1connector.html#a44295925e0bd5f76ac8183fad30d58fc">io_service</a></td></tr>
<tr class="memdesc:a44295925e0bd5f76ac8183fad30d58fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mandatory io_service object.  <a href="#a44295925e0bd5f76ac8183fad30d58fc"></a><br/></td></tr>
<tr class="memitem:a9a809de4ec058a15991953f986dbf508"><td class="memItemLeft" align="right" valign="top">boost::asio::local::stream_protocol::socket *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1connector.html#a9a809de4ec058a15991953f986dbf508">socket</a></td></tr>
<tr class="memdesc:a9a809de4ec058a15991953f986dbf508"><td class="mdescLeft">&#160;</td><td class="mdescRight">The socket.  <a href="#a9a809de4ec058a15991953f986dbf508"></a><br/></td></tr>
<tr class="memitem:a75190c3b5be6b76ff61d4fab33621de1"><td class="memItemLeft" align="right" valign="top">boost::asio::local::stream_protocol::endpoint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1connector.html#a75190c3b5be6b76ff61d4fab33621de1">endpoint</a></td></tr>
<tr class="memdesc:a75190c3b5be6b76ff61d4fab33621de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The endpoint used for unix domain sockets.  <a href="#a75190c3b5be6b76ff61d4fab33621de1"></a><br/></td></tr>
<tr class="memitem:a192e6f537df2fdcbe640dd7301264a9c"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="types_8hpp.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>, <br class="typebreak"/>
boost::shared_ptr&lt; <a class="el" href="classagentxcpp_1_1_response_p_d_u.html">ResponsePDU</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1connector.html#a192e6f537df2fdcbe640dd7301264a9c">responses</a></td></tr>
<tr class="memdesc:a192e6f537df2fdcbe640dd7301264a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The received, yet unprocessed ReponsePDU's.  <a href="#a192e6f537df2fdcbe640dd7301264a9c"></a><br/></td></tr>
<tr class="memitem:a9bc91e90d4bff11aee2932d6c70d172f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8hpp.html#a780bd50362a995b802eb8e00f4b0c200">byte_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1connector.html#a9bc91e90d4bff11aee2932d6c70d172f">header_buf</a> [20]</td></tr>
<tr class="memdesc:a9bc91e90d4bff11aee2932d6c70d172f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer to receive a <a class="el" href="classagentxcpp_1_1_p_d_u.html" title="The base class of all PDU&#39;s.">PDU</a> header.  <a href="#a9bc91e90d4bff11aee2932d6c70d172f"></a><br/></td></tr>
<tr class="memitem:afe1f4f84618fef58cd0065847498aa24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classagentxcpp_1_1connector_1_1pdu__handler.html">pdu_handler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1connector.html#afe1f4f84618fef58cd0065847498aa24">handler</a></td></tr>
<tr class="memdesc:afe1f4f84618fef58cd0065847498aa24"><td class="mdescLeft">&#160;</td><td class="mdescRight">The handler object for incoming PDU's.  <a href="#afe1f4f84618fef58cd0065847498aa24"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This class provides connection to another agentXcpp entity via a unix domain socket. </p>
<p>A connector object is always in one of the following states:</p>
<ol type="1">
<li>connected<ol type="a">
<li>disconnected</li>
</ol>
</li>
</ol>
<p>When created, a connector object starts in disconnected state. The current state can be obtained using the <a class="el" href="classagentxcpp_1_1connector.html#ae2de68485ec32d9f944266d6ffb3003e" title="Find out whether the object is currently connected.">is_connected()</a> method. Some operations may throw a disconnected exception if the object is in disconnected state. Further, the connection may fail at any point in time, therefore a disconnected exception may also be thrown during a network operation.</p>
<p>The socket needed for networking is created upon connect and destroyed upon disconnect. The reason is that closing the socket may throw a system_error exception, leaving the socket in an unknown state. Destroying it and creating a new one should be safe.</p>
<p>Sending works as follows:</p>
<ul>
<li>The user invokes the <a class="el" href="classagentxcpp_1_1connector.html#a4f59919d2c688e62111133a927ed190c" title="send a PDU to the remote entity.">send()</a> method.<ul>
<li>The <a class="el" href="classagentxcpp_1_1connector.html#a4f59919d2c688e62111133a927ed190c" title="send a PDU to the remote entity.">send()</a> method sends the PDU synchronously (but with a timeout).</li>
</ul>
</li>
</ul>
<p>Note: The <a class="el" href="classagentxcpp_1_1connector.html#a4f59919d2c688e62111133a927ed190c" title="send a PDU to the remote entity.">send()</a> function invokes io_service-&gt;run_one() one or several times.</p>
<p>Receiving PDU's works as follows:</p>
<ul>
<li>Upon connecting to the remote entity, an asynchronous read operation is started to receive the PDU header (fixed size). On disconnect, the asynchronous read operation is stopped again.<ul>
<li>The boost::asio library writes a fixed amount of data (which is the PDU header) into the header_buf member and invokes the <a class="el" href="classagentxcpp_1_1connector.html#a84511fbf6e1a62c1dfcdba8da7c40c81" title="Callback function to receive a PDU.">receive_callback()</a> function.</li>
<li>The <a class="el" href="classagentxcpp_1_1connector.html#a84511fbf6e1a62c1dfcdba8da7c40c81" title="Callback function to receive a PDU.">receive_callback()</a> method reads the payload length from header_buf and reveives the payload synchronously (but with a timeout).</li>
<li>The <a class="el" href="classagentxcpp_1_1connector.html#a84511fbf6e1a62c1dfcdba8da7c40c81" title="Callback function to receive a PDU.">receive_callback()</a> method then constructs a <a class="el" href="classagentxcpp_1_1_p_d_u.html" title="The base class of all PDU&#39;s.">PDU</a> object and delivers it to a user-provided handler object (which implements the <a class="el" href="classagentxcpp_1_1connector_1_1pdu__handler.html" title="Interface for classes which can handle incoming PDU&#39;s.">connector::pdu_handler</a> interface) by calling its handle_pdu() method.</li>
<li>The handler object processes the PDU as needed. As soon as processing finishes, the <a class="el" href="classagentxcpp_1_1connector.html#a84511fbf6e1a62c1dfcdba8da7c40c81" title="Callback function to receive a PDU.">receive_callback()</a> method starts the next asynchronous read operation, so that it invoked again when the next header arrives.</li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note:</dt><dd>As a special case, <a class="el" href="classagentxcpp_1_1_response_p_d_u.html" title="Represents an Response-PDU.">ResponsePDU</a>'s are not delivered to the registered handler object, but are handled differently. see below for details.</dd>
<dd>
If no handler object is registered, the PDU is received nevertheless and is silently discarded.</dd>
<dd>
The <a class="el" href="classagentxcpp_1_1connector.html#a84511fbf6e1a62c1dfcdba8da7c40c81" title="Callback function to receive a PDU.">receive_callback()</a> function, and thus the registered handler object's handle_pdu() method are executed in the io_service's run() context. </dd></dl>
<p>Receiving ResponsePDU's works as follows:</p>
<p>The function <a class="el" href="classagentxcpp_1_1connector.html#a9b4effeb519301d589e11fe2914c1f09" title="Wait with timeout for a reponse.">wait_for_response()</a> supports the request-response communication model. After sending a request to the remote entity (using <a class="el" href="classagentxcpp_1_1connector.html#a4f59919d2c688e62111133a927ed190c" title="send a PDU to the remote entity.">send()</a>), <a class="el" href="classagentxcpp_1_1connector.html#a9b4effeb519301d589e11fe2914c1f09" title="Wait with timeout for a reponse.">wait_for_response()</a> is used to wait for the response. It blocks while waiting for a responsePDU from the remote entity, which is then returned to the caller. The <a class="el" href="classagentxcpp_1_1connector.html#a9b4effeb519301d589e11fe2914c1f09" title="Wait with timeout for a reponse.">wait_for_response()</a> function may seem to do synchronous operations only, but this is not true. In fact, it uses an asynchronous receive mechanism, because there may be other PDU's in the queue before the given response is actually received. <a class="el" href="classagentxcpp_1_1connector.html#a9b4effeb519301d589e11fe2914c1f09" title="Wait with timeout for a reponse.">wait_for_response()</a> therefore invokes io_service-&gt;run_one() one ore more times, until the response is received. This may also cause other asynchronous operations to finish. For example, the registered handler object may receive other PDU types, or another asynchronous operation on the io_service object (outside this class or even outside the agentXcpp library) may be served. Here are the steps performed to receive a <a class="el" href="classagentxcpp_1_1_response_p_d_u.html" title="Represents an Response-PDU.">ResponsePDU</a>:</p>
<ul>
<li>The <a class="el" href="classagentxcpp_1_1connector.html#a9b4effeb519301d589e11fe2914c1f09" title="Wait with timeout for a reponse.">wait_for_response()</a> function puts an empty boost::shared_ptr&lt;&gt; into the responses map, using the PacketID of the awaited <a class="el" href="classagentxcpp_1_1_response_p_d_u.html" title="Represents an Response-PDU.">ResponsePDU</a> as key.<ul>
<li>The <a class="el" href="classagentxcpp_1_1connector.html#a9b4effeb519301d589e11fe2914c1f09" title="Wait with timeout for a reponse.">wait_for_response()</a> function invokes io_service-&gt;run_one() one or several times, which triggers <a class="el" href="classagentxcpp_1_1connector.html#a84511fbf6e1a62c1dfcdba8da7c40c81" title="Callback function to receive a PDU.">receive_callback()</a> if data becomes available.</li>
<li>When the <a class="el" href="classagentxcpp_1_1connector.html#a84511fbf6e1a62c1dfcdba8da7c40c81" title="Callback function to receive a PDU.">receive_callback()</a> function is invoked, it receives a single PDU and processes it as described above.</li>
<li>If a <a class="el" href="classagentxcpp_1_1_response_p_d_u.html" title="Represents an Response-PDU.">ResponsePDU</a> is received, the registered handler object is not informed by <a class="el" href="classagentxcpp_1_1connector.html#a84511fbf6e1a62c1dfcdba8da7c40c81" title="Callback function to receive a PDU.">receive_callback()</a>. Instead, the responses map is searched for an entry with the same PacketID as the received <a class="el" href="classagentxcpp_1_1_response_p_d_u.html" title="Represents an Response-PDU.">ResponsePDU</a>. If found, the received <a class="el" href="classagentxcpp_1_1_response_p_d_u.html" title="Represents an Response-PDU.">ResponsePDU</a> is stored in the map. Otherwise the <a class="el" href="classagentxcpp_1_1_response_p_d_u.html" title="Represents an Response-PDU.">ResponsePDU</a> is silently discarded (as nobody waits for it).</li>
<li>The <a class="el" href="classagentxcpp_1_1connector.html#a9b4effeb519301d589e11fe2914c1f09" title="Wait with timeout for a reponse.">wait_for_response()</a> checks its map entry after each run_one() call for a received <a class="el" href="classagentxcpp_1_1_response_p_d_u.html" title="Represents an Response-PDU.">ResponsePDU</a>. If it finds one, the entry is erased from the map and returned to the caller.</li>
</ul>
</li>
</ul>
<p>The same timeout value is used by all operations which deal with timeouts. The value is stored in the timeout member. </p>

<p>Definition at line <a class="el" href="connector_8hpp_source.html#l00129">129</a> of file <a class="el" href="connector_8hpp_source.html">connector.hpp</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9b1d09d8700ee2b15c38644a65d259b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classagentxcpp_1_1connector.html#a9b1d09d8700ee2b15c38644a65d259b3">agentxcpp::connector::connector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hide standard constructor. </p>
<p>We need an io_service object to function properly. </p>

</div>
</div>
<a class="anchor" id="ac66b42853b9dd85f3c2b7ee9a0e6bc39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classagentxcpp_1_1connector.html#a9b1d09d8700ee2b15c38644a65d259b3">connector::connector</a> </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; boost::asio::io_service &gt;&#160;</td>
          <td class="paramname"><em>io_service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unix_domain_socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The constructor. </p>
<p>This constructor initializes the connector object to be in disconnected state.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">io_service</td><td>The io_service object needed for boost::asio operations. It may also be used by other parts of the program.</td></tr>
    <tr><td class="paramname">unix_domain_socket</td><td>The path to the unix_domain_socket.</td></tr>
    <tr><td class="paramname">timeout</td><td>The timeout, in milliseconds, for sending and receiving PDU's. See the documentation of the respective methods for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="connector_8cpp_source.html#l00410">410</a> of file <a class="el" href="connector_8cpp_source.html">connector.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2b10934a5124edc0f78453c50fe36884"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classagentxcpp_1_1connector.html#a2b10934a5124edc0f78453c50fe36884">agentxcpp::connector::~connector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="connector_8hpp_source.html#l00423">423</a> of file <a class="el" href="connector_8hpp_source.html">connector.hpp</a>.</p>

<p>References <a class="el" href="classagentxcpp_1_1connector.html#ae402d364dfc5b6a1f794256cb2823a0d">disconnect()</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a0d5c81d1908b7db51d1080453dd5289b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classagentxcpp_1_1connector.html#a0d5c81d1908b7db51d1080453dd5289b">connector::connect</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connect to the remote entity. </p>
<p>This function connects to the remote entity and starts receiving PDU's. If the object is already connected, the function does nothing.</p>
<dl class="section note"><dt>Note:</dt><dd>While no handler is registered, received PDU's are silently discarded.</dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">disconnected</td><td>If connecting fails. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="connector_8cpp_source.html#l00421">421</a> of file <a class="el" href="connector_8cpp_source.html">connector.cpp</a>.</p>

<p>References <a class="el" href="classagentxcpp_1_1connector.html#a75190c3b5be6b76ff61d4fab33621de1">endpoint</a>, <a class="el" href="classagentxcpp_1_1connector.html#a9bc91e90d4bff11aee2932d6c70d172f">header_buf</a>, <a class="el" href="classagentxcpp_1_1connector.html#a44295925e0bd5f76ac8183fad30d58fc">io_service</a>, <a class="el" href="classagentxcpp_1_1connector.html#a84511fbf6e1a62c1dfcdba8da7c40c81">receive_callback()</a>, and <a class="el" href="classagentxcpp_1_1connector.html#a9a809de4ec058a15991953f986dbf508">socket</a>.</p>

<p>Referenced by <a class="el" href="classagentxcpp_1_1master__proxy.html#a25f794f0abc4b988f7e3f2be4735160c">agentxcpp::master_proxy::connect()</a>, and <a class="el" href="classagentxcpp_1_1master__proxy.html#a84db5e9df0926eae5938b95cb056c120">agentxcpp::master_proxy::reconnect()</a>.</p>

</div>
</div>
<a class="anchor" id="ae402d364dfc5b6a1f794256cb2823a0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classagentxcpp_1_1connector.html#ae402d364dfc5b6a1f794256cb2823a0d">connector::disconnect</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnect the remote entity. </p>
<p>Stops receiving PDU's and disconnects the remote entity.</p>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="connector_8cpp_source.html#l00454">454</a> of file <a class="el" href="connector_8cpp_source.html">connector.cpp</a>.</p>

<p>References <a class="el" href="classagentxcpp_1_1connector.html#a9a809de4ec058a15991953f986dbf508">socket</a>.</p>

<p>Referenced by <a class="el" href="classagentxcpp_1_1master__proxy.html#a25f794f0abc4b988f7e3f2be4735160c">agentxcpp::master_proxy::connect()</a>, <a class="el" href="classagentxcpp_1_1master__proxy.html#a8894319cc158a911034c155d5533a51d">agentxcpp::master_proxy::disconnect()</a>, <a class="el" href="classagentxcpp_1_1connector.html#a84511fbf6e1a62c1dfcdba8da7c40c81">receive_callback()</a>, <a class="el" href="classagentxcpp_1_1master__proxy.html#a84db5e9df0926eae5938b95cb056c120">agentxcpp::master_proxy::reconnect()</a>, <a class="el" href="classagentxcpp_1_1connector.html#a4f59919d2c688e62111133a927ed190c">send()</a>, <a class="el" href="classagentxcpp_1_1connector.html#a9b4effeb519301d589e11fe2914c1f09">wait_for_response()</a>, and <a class="el" href="classagentxcpp_1_1connector.html#a2b10934a5124edc0f78453c50fe36884">~connector()</a>.</p>

</div>
</div>
<a class="anchor" id="ae2de68485ec32d9f944266d6ffb3003e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classagentxcpp_1_1connector.html#ae2de68485ec32d9f944266d6ffb3003e">agentxcpp::connector::is_connected</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find out whether the object is currently connected. </p>
<dl class="section return"><dt>Returns:</dt><dd>Whether the object is in state connected.</dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="connector_8hpp_source.html#l00388">388</a> of file <a class="el" href="connector_8hpp_source.html">connector.hpp</a>.</p>

<p>References <a class="el" href="classagentxcpp_1_1connector.html#a9a809de4ec058a15991953f986dbf508">socket</a>.</p>

<p>Referenced by <a class="el" href="classagentxcpp_1_1master__proxy.html#a25f794f0abc4b988f7e3f2be4735160c">agentxcpp::master_proxy::connect()</a>, <a class="el" href="classagentxcpp_1_1master__proxy.html#a8894319cc158a911034c155d5533a51d">agentxcpp::master_proxy::disconnect()</a>, and <a class="el" href="classagentxcpp_1_1master__proxy.html#a9a92916553e334f3675e430e9848ecf9">agentxcpp::master_proxy::is_connected()</a>.</p>

</div>
</div>
<a class="anchor" id="a84511fbf6e1a62c1dfcdba8da7c40c81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classagentxcpp_1_1connector.html#a84511fbf6e1a62c1dfcdba8da7c40c81">connector::receive_callback</a> </td>
          <td>(</td>
          <td class="paramtype">const boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback function to receive a PDU. </p>
<p>See the class documentation to learn about the receive mechanism.</p>
<dl class="section note"><dt>Note:</dt><dd>Exceptions thrown by the user-provided handler (if any) are catched and discarded.</dd></dl>
<p>The synchronous read operation (to read the payload) may time out, using the class' timeout value. If the read times out, the socket is destroyed and the connector object becomes disconnected.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The result of the asynchronous read operation (provided by boost::asio).</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="connector_8cpp_source.html#l00502">502</a> of file <a class="el" href="connector_8cpp_source.html">connector.cpp</a>.</p>

<p>References <a class="el" href="classagentxcpp_1_1connector.html#ae402d364dfc5b6a1f794256cb2823a0d">disconnect()</a>, <a class="el" href="classagentxcpp_1_1connector_1_1pdu__handler.html#a2b445c92b77793696b615373a3f521f5">agentxcpp::connector::pdu_handler::handle_pdu()</a>, <a class="el" href="classagentxcpp_1_1connector.html#afe1f4f84618fef58cd0065847498aa24">handler</a>, <a class="el" href="classagentxcpp_1_1connector.html#a9bc91e90d4bff11aee2932d6c70d172f">header_buf</a>, <a class="el" href="classagentxcpp_1_1_p_d_u.html#a233eeff1fbbde1adf46ce29f7ec75d21">agentxcpp::PDU::parse_pdu()</a>, <a class="el" href="helper_8hpp.html#a46cdc141dd55ff1b0925a329bce53fbf">read32()</a>, <a class="el" href="classagentxcpp_1_1connector.html#a192e6f537df2fdcbe640dd7301264a9c">responses</a>, and <a class="el" href="classagentxcpp_1_1connector.html#a9a809de4ec058a15991953f986dbf508">socket</a>.</p>

<p>Referenced by <a class="el" href="classagentxcpp_1_1connector.html#a0d5c81d1908b7db51d1080453dd5289b">connect()</a>.</p>

</div>
</div>
<a class="anchor" id="ad4be113f201584ce0fd15d24d4929def"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classagentxcpp_1_1connector.html#ad4be113f201584ce0fd15d24d4929def">connector::register_handler</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classagentxcpp_1_1connector_1_1pdu__handler.html">pdu_handler</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register a handler object for received PDU's. </p>
<p>Every time a PDU is received, the handler object's handle_pdu() method will be invoked with the PDU as argument. This method is executed in the context of the io_service object's run() or run_one() method. Care should be taken to not block the call, e.g. by doing networking.</p>
<p>After registering a handler it can be unregistered again by calling this function with a null pointer. While no handler object is registered, received PDU's are silently discarded.</p>
<dl class="section note"><dt>Note:</dt><dd>Any exceptions thrown by the handler object are silently discarded.</dd>
<dd>
There can be only one handler object registered at a time.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>A pointer to the handler object, or null.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="connector_8cpp_source.html#l00496">496</a> of file <a class="el" href="connector_8cpp_source.html">connector.cpp</a>.</p>

<p>References <a class="el" href="classagentxcpp_1_1connector.html#afe1f4f84618fef58cd0065847498aa24">handler</a>.</p>

<p>Referenced by <a class="el" href="classagentxcpp_1_1master__proxy.html#a87c9b9f7e343473a52aa89e18e564a43">agentxcpp::master_proxy::master_proxy()</a>.</p>

</div>
</div>
<a class="anchor" id="a4f59919d2c688e62111133a927ed190c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classagentxcpp_1_1connector.html#a4f59919d2c688e62111133a927ed190c">connector::send</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classagentxcpp_1_1_p_d_u.html">PDU</a> &amp;&#160;</td>
          <td class="paramname"><em>pdu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>send a PDU to the remote entity. </p>
<p>The PDU is sent to the remote entity. If the timeout expires during the send operation, a <a class="el" href="classagentxcpp_1_1timeout__error.html" title="Exception to indicate a timeout.">timeout_error</a> is thrown and the object gets disconnected.</p>
<dl class="section note"><dt>Note:</dt><dd>The run_one() of the io_service object is called at least one time by this operation.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pdu</td><td>The <a class="el" href="classagentxcpp_1_1_p_d_u.html" title="The base class of all PDU&#39;s.">PDU</a> to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classagentxcpp_1_1timeout__error.html" title="Exception to indicate a timeout.">timeout_error</a></td><td>If a timeout error occurs. The function uses the timeout value given during construction. The objects gets disconnected in this case. Some data might be sent already.</td></tr>
    <tr><td class="paramname">disconnected</td><td>If disconnected. This is also thrown if sending fails and the object gets disconnected for that reason. Some data might be sent already. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="connector_8cpp_source.html#l00665">665</a> of file <a class="el" href="connector_8cpp_source.html">connector.cpp</a>.</p>

<p>References <a class="el" href="classagentxcpp_1_1connector.html#ae402d364dfc5b6a1f794256cb2823a0d">disconnect()</a>, <a class="el" href="classagentxcpp_1_1_p_d_u.html#a0c59e3f1b66ddb11e816dc9c809ed0ef">agentxcpp::PDU::serialize()</a>, and <a class="el" href="classagentxcpp_1_1connector.html#a9a809de4ec058a15991953f986dbf508">socket</a>.</p>

<p>Referenced by <a class="el" href="classagentxcpp_1_1master__proxy.html#a25f794f0abc4b988f7e3f2be4735160c">agentxcpp::master_proxy::connect()</a>, <a class="el" href="classagentxcpp_1_1master__proxy.html#a8894319cc158a911034c155d5533a51d">agentxcpp::master_proxy::disconnect()</a>, <a class="el" href="classagentxcpp_1_1master__proxy.html#ab9388194aa324aafdbf57085ab80fec1">agentxcpp::master_proxy::do_registration()</a>, <a class="el" href="classagentxcpp_1_1master__proxy.html#a4c346089b8ecf581d055de709593631d">agentxcpp::master_proxy::handle_pdu()</a>, and <a class="el" href="classagentxcpp_1_1master__proxy.html#ac73c6299c8530284b366b6570f951e13">agentxcpp::master_proxy::undo_registration()</a>.</p>

</div>
</div>
<a class="anchor" id="a9b4effeb519301d589e11fe2914c1f09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; <a class="el" href="classagentxcpp_1_1_response_p_d_u.html">ResponsePDU</a> &gt; <a class="el" href="classagentxcpp_1_1connector.html#a9b4effeb519301d589e11fe2914c1f09">connector::wait_for_response</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>packetID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait with timeout for a reponse. </p>
<p>This function blocks until a <a class="el" href="classagentxcpp_1_1_response_p_d_u.html" title="Represents an Response-PDU.">ResponsePDU</a> with the given packetID is received or until the timeout expires, whichever comes first. The received <a class="el" href="classagentxcpp_1_1_response_p_d_u.html" title="Represents an Response-PDU.">ResponsePDU</a> (if any) is returned.</p>
<p>This function calls run_one() repeatedly on the io_service object until the desired <a class="el" href="classagentxcpp_1_1_response_p_d_u.html" title="Represents an Response-PDU.">ResponsePDU</a> arrives or the timeout expires. This may cause other asynchronous operations to be served, as well.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">packetID</td><td>The packetID to wait for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">timeout_exception</td><td>If the timeout expired before the <a class="el" href="classagentxcpp_1_1_response_p_d_u.html" title="Represents an Response-PDU.">ResponsePDU</a> was received. The connector object stays in connected state.</td></tr>
    <tr><td class="paramname">disconnected</td><td>If disconnected. This is also thrown if the operation fails and the object gets disconnected for that reason.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The received <a class="el" href="classagentxcpp_1_1_response_p_d_u.html" title="Represents an Response-PDU.">ResponsePDU</a>. </dd></dl>

<p>Definition at line <a class="el" href="connector_8cpp_source.html#l00733">733</a> of file <a class="el" href="connector_8cpp_source.html">connector.cpp</a>.</p>

<p>References <a class="el" href="classagentxcpp_1_1connector.html#ae402d364dfc5b6a1f794256cb2823a0d">disconnect()</a>, <a class="el" href="connector_8cpp.html#af9bff8ff1154a04a899276af806b8586ac66a9c3a70b4ca472b83474aba3a87f0">in_progress</a>, <a class="el" href="classagentxcpp_1_1connector.html#a44295925e0bd5f76ac8183fad30d58fc">io_service</a>, <a class="el" href="classagentxcpp_1_1connector.html#a192e6f537df2fdcbe640dd7301264a9c">responses</a>, and <a class="el" href="classagentxcpp_1_1connector.html#a9a809de4ec058a15991953f986dbf508">socket</a>.</p>

<p>Referenced by <a class="el" href="classagentxcpp_1_1master__proxy.html#a25f794f0abc4b988f7e3f2be4735160c">agentxcpp::master_proxy::connect()</a>, <a class="el" href="classagentxcpp_1_1master__proxy.html#a8894319cc158a911034c155d5533a51d">agentxcpp::master_proxy::disconnect()</a>, <a class="el" href="classagentxcpp_1_1master__proxy.html#ab9388194aa324aafdbf57085ab80fec1">agentxcpp::master_proxy::do_registration()</a>, and <a class="el" href="classagentxcpp_1_1master__proxy.html#ac73c6299c8530284b366b6570f951e13">agentxcpp::master_proxy::undo_registration()</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a75190c3b5be6b76ff61d4fab33621de1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::asio::local::stream_protocol::endpoint <a class="el" href="classagentxcpp_1_1connector.html#a75190c3b5be6b76ff61d4fab33621de1">agentxcpp::connector::endpoint</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The endpoint used for unix domain sockets. </p>

<p>Definition at line <a class="el" href="connector_8hpp_source.html#l00203">203</a> of file <a class="el" href="connector_8hpp_source.html">connector.hpp</a>.</p>

<p>Referenced by <a class="el" href="classagentxcpp_1_1connector.html#a0d5c81d1908b7db51d1080453dd5289b">connect()</a>.</p>

</div>
</div>
<a class="anchor" id="afe1f4f84618fef58cd0065847498aa24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classagentxcpp_1_1connector_1_1pdu__handler.html">pdu_handler</a>* <a class="el" href="classagentxcpp_1_1connector.html#afe1f4f84618fef58cd0065847498aa24">agentxcpp::connector::handler</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The handler object for incoming PDU's. </p>
<p>This handler object is informed by <a class="el" href="classagentxcpp_1_1connector.html#a84511fbf6e1a62c1dfcdba8da7c40c81" title="Callback function to receive a PDU.">receive_callback()</a> for each received <a class="el" href="classagentxcpp_1_1_p_d_u.html" title="The base class of all PDU&#39;s.">PDU</a> (except <a class="el" href="classagentxcpp_1_1_response_p_d_u.html" title="Represents an Response-PDU.">ResponsePDU</a>'s).</p>
<p>The pointer may be null, which means that there is no handler object registered. </p>

<p>Definition at line <a class="el" href="connector_8hpp_source.html#l00272">272</a> of file <a class="el" href="connector_8hpp_source.html">connector.hpp</a>.</p>

<p>Referenced by <a class="el" href="classagentxcpp_1_1connector.html#a84511fbf6e1a62c1dfcdba8da7c40c81">receive_callback()</a>, and <a class="el" href="classagentxcpp_1_1connector.html#ad4be113f201584ce0fd15d24d4929def">register_handler()</a>.</p>

</div>
</div>
<a class="anchor" id="a9bc91e90d4bff11aee2932d6c70d172f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8hpp.html#a780bd50362a995b802eb8e00f4b0c200">byte_t</a> <a class="el" href="classagentxcpp_1_1connector.html#a9bc91e90d4bff11aee2932d6c70d172f">agentxcpp::connector::header_buf</a>[20]<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Buffer to receive a <a class="el" href="classagentxcpp_1_1_p_d_u.html" title="The base class of all PDU&#39;s.">PDU</a> header. </p>
<p>See the class documentation to learn about the receive mechanism.</p>
<p>The PDU header is placed here before <a class="el" href="classagentxcpp_1_1connector.html#a84511fbf6e1a62c1dfcdba8da7c40c81" title="Callback function to receive a PDU.">receive_callback()</a> is called by boost::asio.</p>
<p>Since the AgentX-header is always 20 bytes in length, this buffer is 20 bytes in size. </p>

<p>Definition at line <a class="el" href="connector_8hpp_source.html#l00261">261</a> of file <a class="el" href="connector_8hpp_source.html">connector.hpp</a>.</p>

<p>Referenced by <a class="el" href="classagentxcpp_1_1connector.html#a0d5c81d1908b7db51d1080453dd5289b">connect()</a>, and <a class="el" href="classagentxcpp_1_1connector.html#a84511fbf6e1a62c1dfcdba8da7c40c81">receive_callback()</a>.</p>

</div>
</div>
<a class="anchor" id="a44295925e0bd5f76ac8183fad30d58fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;boost::asio::io_service&gt; <a class="el" href="classagentxcpp_1_1connector.html#a44295925e0bd5f76ac8183fad30d58fc">agentxcpp::connector::io_service</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The mandatory io_service object. </p>
<p>This object is needed for boost::asio sockets. It is provided by the user of this class. </p>

<p>Definition at line <a class="el" href="connector_8hpp_source.html#l00191">191</a> of file <a class="el" href="connector_8hpp_source.html">connector.hpp</a>.</p>

<p>Referenced by <a class="el" href="classagentxcpp_1_1connector.html#a0d5c81d1908b7db51d1080453dd5289b">connect()</a>, and <a class="el" href="classagentxcpp_1_1connector.html#a9b4effeb519301d589e11fe2914c1f09">wait_for_response()</a>.</p>

</div>
</div>
<a class="anchor" id="a192e6f537df2fdcbe640dd7301264a9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; <a class="el" href="types_8hpp.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>, boost::shared_ptr&lt;<a class="el" href="classagentxcpp_1_1_response_p_d_u.html">ResponsePDU</a>&gt; &gt; <a class="el" href="classagentxcpp_1_1connector.html#a192e6f537df2fdcbe640dd7301264a9c">agentxcpp::connector::responses</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The received, yet unprocessed ReponsePDU's. </p>
<p>See the class documentation to learn about the receive mechanism.</p>
<p>The <a class="el" href="classagentxcpp_1_1connector.html#a9b4effeb519301d589e11fe2914c1f09" title="Wait with timeout for a reponse.">wait_for_response()</a> function stores a null pointer to this map to indicate that it is waiting for a certain response.</p>
<p>When a response is received, the <a class="el" href="classagentxcpp_1_1connector.html#a84511fbf6e1a62c1dfcdba8da7c40c81" title="Callback function to receive a PDU.">receive_callback()</a> function stores it into the map, but only if a null pointer is found for the packetID of the received <a class="el" href="classagentxcpp_1_1_response_p_d_u.html" title="Represents an Response-PDU.">ResponsePDU</a>. Otherwise, the received <a class="el" href="classagentxcpp_1_1_response_p_d_u.html" title="Represents an Response-PDU.">ResponsePDU</a> is discarded.</p>
<p>After a <a class="el" href="classagentxcpp_1_1_response_p_d_u.html" title="Represents an Response-PDU.">ResponsePDU</a> was received and stored into the map, the <a class="el" href="classagentxcpp_1_1connector.html#a9b4effeb519301d589e11fe2914c1f09" title="Wait with timeout for a reponse.">wait_for_response()</a> function processes it and erases it from the map.</p>
<p>The map key is the packetID of the response which is awaited. </p>

<p>Definition at line <a class="el" href="connector_8hpp_source.html#l00246">246</a> of file <a class="el" href="connector_8hpp_source.html">connector.hpp</a>.</p>

<p>Referenced by <a class="el" href="classagentxcpp_1_1connector.html#a84511fbf6e1a62c1dfcdba8da7c40c81">receive_callback()</a>, and <a class="el" href="classagentxcpp_1_1connector.html#a9b4effeb519301d589e11fe2914c1f09">wait_for_response()</a>.</p>

</div>
</div>
<a class="anchor" id="a9a809de4ec058a15991953f986dbf508"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::asio::local::stream_protocol::socket* <a class="el" href="classagentxcpp_1_1connector.html#a9a809de4ec058a15991953f986dbf508">agentxcpp::connector::socket</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The socket. </p>
<p>The null pointer while disconnected. </p>

<p>Definition at line <a class="el" href="connector_8hpp_source.html#l00198">198</a> of file <a class="el" href="connector_8hpp_source.html">connector.hpp</a>.</p>

<p>Referenced by <a class="el" href="classagentxcpp_1_1connector.html#a0d5c81d1908b7db51d1080453dd5289b">connect()</a>, <a class="el" href="classagentxcpp_1_1connector.html#ae402d364dfc5b6a1f794256cb2823a0d">disconnect()</a>, <a class="el" href="classagentxcpp_1_1connector.html#ae2de68485ec32d9f944266d6ffb3003e">is_connected()</a>, <a class="el" href="classagentxcpp_1_1connector.html#a84511fbf6e1a62c1dfcdba8da7c40c81">receive_callback()</a>, <a class="el" href="classagentxcpp_1_1connector.html#a4f59919d2c688e62111133a927ed190c">send()</a>, and <a class="el" href="classagentxcpp_1_1connector.html#a9b4effeb519301d589e11fe2914c1f09">wait_for_response()</a>.</p>

</div>
</div>
<a class="anchor" id="ad333ffb80e2359241c86364fa8be8a96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classagentxcpp_1_1connector.html#ad333ffb80e2359241c86364fa8be8a96">agentxcpp::connector::timeout</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The timeout in milliseconds, used in various contexts. </p>

<p>Definition at line <a class="el" href="connector_8hpp_source.html#l00183">183</a> of file <a class="el" href="connector_8hpp_source.html">connector.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/tanjeff/projekte/agentxcpp/src/<a class="el" href="connector_8hpp_source.html">connector.hpp</a></li>
<li>/home/tanjeff/projekte/agentxcpp/src/<a class="el" href="connector_8cpp_source.html">connector.cpp</a></li>
</ul>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>agentxcpp</b>      </li>
      <li class="navelem"><a class="el" href="classagentxcpp_1_1connector.html">connector</a>      </li>

    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.0 </li>
   </ul>
 </div>


</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>AgentXcpp: How to implement a writeable variable</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="doc_logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">AgentXcpp
   &#160;<span id="projectnumber">Version:0.3</span>
   </div>
   <div id="projectbrief">Internals Documentation</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('how_to_add_rw_support.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">How to implement a writeable variable </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section note"><dt>Note</dt><dd>This is a follow-up tutorial to <a class="el" href="how_to_write_a_subagent.html">How to write a Subagent</a>.</dd></dl>
<p>In the previous tutorial we wrote a simple read-only counter variable. Here we will continue this work and add write support to the simpleCounter variable. Writing to the variable will set it to a new value, and it will continue to count from there.</p>
<p>The updated MIB looks like that:</p>
<pre class="fragment">SIMPLE-MIB DEFINITIONS ::= BEGIN

IMPORTS
    OBJECT-TYPE FROM SNMPv2-SMI
    enterprises FROM SNMPv2-SMI;

simpleCounter OBJECT-TYPE
    SYNTAX INTEGER
    ACCESS read-write
    STATUS current
    DESCRIPTION "A simple counter which is incremented each time
                 it is queried. Starts with 0."
    ::={ enterprises 42 1 }

END
</pre><p>This is the same as before, but with "ACCESS read-write".</p>
<h1><a class="anchor" id="the_set_steps"></a>
The anatomy of a Set request</h1>
<p>A single SNMP Set request may set multiple variables at once (possibly distributed over multiple subagents), and SNMP guarantees an atomic operation in that case. This means that, should any variable fail to perform the Set operation, no other variable is allowed to perform the Set operation either. Therefore, the SET operation is carried out in multiple distinct steps:</p>
<ol type="1">
<li><b>TestSet</b> checks whether the variable could be set at all. This step is performed for all variables (in all subagents) affected by the single SNMP Set request. If any variable is not able to accept its new value, the Set operation is aborted, and the next step "CommitSet" is skipped (and no variable gets updated). During this step subagents shall allocate the resources they need to carry out the Set operation later, but they shall not update their value yet.</li>
<li><b>CommitSet</b> actually sets the new value. This step may fail for a variable, even if the TestSet step announced that the CommitSet would work. If that happens, all other variables which already performed the CommitSet must undo their action (which is done in the UndoSet step). It is strongly recommended to implement variables in such a way that CommitSet does not fail, when possible.</li>
<li>The third step is one of the following:<ul>
<li><b>CleanupSet</b> is usually the last step, performed after CommitSet was successful for all variables. In the CleanupSet step, the subagent shall release any resources which where allocated in the TestSet step.</li>
<li><b>UndoSet</b> may be performed if CommitSet failed for any variable. UndoSet is then called for all variables which already performed CommitSet and therefore must undo their action. For variables which didn't perform CommitSet yet, CleanupSet is called instead. UndoSet shall undo the actions performed by CommitSet and release all resources which were allocated in the TestSet step.</li>
</ul>
</li>
</ol>
<p>To implement these actions, the Variable classes provides the methods <code>perform_testset()</code>, <code>perform_commitset()</code>, <code>perform_cleanupset()</code> and <code>perform_undoset()</code>, which can be overridden by a concrete implementation.</p>
<h1><a class="anchor" id="extend_simplecounter"></a>
Extending the SimpleCounter class</h1>
<p>To implement write support for the SimpleCounter class, we implement all four methods. The <code>perform_testset()</code> implementation allocates an quint32 value, which is deallocated by <code>perform_cleanupset()</code> respectively <code>perform_undoset()</code>. This is not very realistic, but it demonstrates the usage of the individual steps. The <code>perform_commitset()</code> method stores the old value (in case an undo needs to be carried out by <code>perform_undoset()</code>) and sets the new value.</p>
<h2><a class="anchor" id="TestSet"></a>
TestSet</h2>
<p>The <code>perform_testset()</code> method must be overridden by any variable which should be writeable. If it is not overridden, agentXcpp assumes that the variable is read-only (which we exploited in the first, read-only version). This also means that an e.g. IntegerVariable object is read-only by default and needs to be subclassed to add write support. Hence, we implement it for our SimpleCounter class by adding the following code to it:</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div>
<div class="line">    quint32* old_value;</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> testset_result_t perform_testset(qint32 new_value)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">try</span></div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Allocate space to store the old value</span></div>
<div class="line">            old_value = <span class="keyword">new</span> quint32;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">catch</span>(std::bad_alloc)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Resource allocation failed.</span></div>
<div class="line">            <span class="keywordflow">return</span> resourceUnavailable;</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// setting the variable will succeed</span></div>
<div class="line">        <span class="keywordflow">return</span> noError;</div>
<div class="line">    }</div>
</div><!-- fragment --><p>The <a class="el" href="classagentxcpp_1_1_integer_variable.html#ad165a7c435826ab1ac49ed37a2774d66">perform_testset()</a> method receives the value and can check whether setting the variable to this value would work. Here, we don't check the value, but we allocate an quint32 to store the old value, which is needed for <code>perform_undoset()</code>. If allocation fails, we return the error <a class="el" href="classagentxcpp_1_1_abstract_variable.html#a694943f11e149c4dd67206c8bc1af72fa139e9f258375323afc503393c62e3647">resourceUnavailable</a>.</p>
<h2><a class="anchor" id="CommitSet"></a>
CommitSet</h2>
<p>The <code>perform_commitset()</code> method must also be implemented for writeable variables. In the SimpleCounter class, this method stores the old value and sets the internal value: </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">bool</span> perform_commitset(qint32 new_value)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Remember old value for rollback</span></div>
<div class="line">    (*old_value) = v;</div>
<div class="line">    <span class="comment">// Set new value</span></div>
<div class="line">    v = new_value;</div>
<div class="line">    <span class="comment">// Operation succeeded</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="CleanupSet"></a>
CleanupSet</h2>
<p>The <code>perform_cleanupset()</code> method releases old_value again:</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> perform_cleanupset(qint32 new_value)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Release old value</span></div>
<div class="line">    <span class="keyword">delete</span> old_value;</div>
<div class="line">}</div>
</div><!-- fragment --><p>If old_value were an quint32 (instead of a pointer to quint32), no allocation and deallocation would have been necessary. The <code>perform_cleanupset()</code> method would not be implemented then. In fact, this method is the only one which is optional for writeable variables, while the other methods are mandatory.</p>
<h2><a class="anchor" id="UndoSet"></a>
UndoSet</h2>
<p>The <code>perform_undoset()</code> method must be implemented by each writeable variable and shall perform a rollback. It is technically possible to omit this method; the compiler has no way to detect a missing implementation. However, it is an error to omit it, and an error will be reported to the master agent if it is missing. For simpleCounter implementation is easy:</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">bool</span> perform_undoset(qint32 new_value)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Restore old value</span></div>
<div class="line">    v = *old_value;</div>
<div class="line">    <span class="comment">// Release old value</span></div>
<div class="line">    <span class="keyword">delete</span> old_value;</div>
<div class="line">    <span class="comment">// Rollback succeeded</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>It's important to note that the method releases old_value.</p>
<h1><a class="anchor" id="try_it_out"></a>
Testing the extended subagent</h1>
<p>Again, we compile and run the subagent. This is exactly the same as in the first tutorial (it is assumed that your system is already setup accordingly):</p>
<pre class="fragment">g++ simpleagent.cpp -o simpleagent -lagentxcpp `pkg-config --cflags --libs QtNetwork QtCore`
</pre><p>Next, we start the subagent again:</p>
<pre class="fragment">./simpleagent
</pre><p>Now, we can query the variable:</p>
<pre class="fragment">snmpget -v1 -c rw localhost SIMPLE-MIB::simpleCounter.0
</pre><p>Each time the variable is queried, the counter increments. Now, let's set the counter to, say, 42:</p>
<pre class="fragment">snmpset -v1 -c rw localhost SIMPLE-MIB::simpleCounter.0 i 42
</pre><p>Now, we continue to query it again several times and the counter should continue at 43, further incrementing.</p>
<p>Et voilá: a read-write variable. Now go on and learn <a class="el" href="how_to_send_notifications.html">how to send notifications</a>! </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>AgentXcpp: agentxcpp::connector Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">AgentXcpp
   &#160;<span id="projectnumber">Revision:4ac4848</span>
   </div>
   <div id="projectbrief">API Documentation</div>
  </td>
  
  
  
   
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classagentxcpp_1_1connector.html','');
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">agentxcpp::connector Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;connector.hpp&gt;</code></p>

<p><a href="classagentxcpp_1_1connector-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1connector_1_1pdu__handler.html">pdu_handler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for classes which can handle incoming PDU's.  <a href="classagentxcpp_1_1connector_1_1pdu__handler.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac66b42853b9dd85f3c2b7ee9a0e6bc39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1connector.html#ac66b42853b9dd85f3c2b7ee9a0e6bc39">connector</a> (boost::shared_ptr&lt; boost::asio::io_service &gt; io_service, const std::string &amp;unix_domain_socket, unsigned timeout)</td></tr>
<tr class="memdesc:ac66b42853b9dd85f3c2b7ee9a0e6bc39"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor.  <a href="#ac66b42853b9dd85f3c2b7ee9a0e6bc39"></a><br/></td></tr>
<tr class="memitem:a9b4effeb519301d589e11fe2914c1f09"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; ResponsePDU &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1connector.html#a9b4effeb519301d589e11fe2914c1f09">wait_for_response</a> (uint32_t packetID)</td></tr>
<tr class="memdesc:a9b4effeb519301d589e11fe2914c1f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait with timeout for a reponse.  <a href="#a9b4effeb519301d589e11fe2914c1f09"></a><br/></td></tr>
<tr class="memitem:a2398a1118dcb2796759c0f74be01f7b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1connector.html#a2398a1118dcb2796759c0f74be01f7b9">register_handler</a> (<a class="el" href="classagentxcpp_1_1connector_1_1pdu__handler.html">pdu_handler</a> *)</td></tr>
<tr class="memdesc:a2398a1118dcb2796759c0f74be01f7b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a handler object for received PDU's.  <a href="#a2398a1118dcb2796759c0f74be01f7b9"></a><br/></td></tr>
<tr class="memitem:a0d5c81d1908b7db51d1080453dd5289b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1connector.html#a0d5c81d1908b7db51d1080453dd5289b">connect</a> ()</td></tr>
<tr class="memdesc:a0d5c81d1908b7db51d1080453dd5289b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to the remote entity.  <a href="#a0d5c81d1908b7db51d1080453dd5289b"></a><br/></td></tr>
<tr class="memitem:ae402d364dfc5b6a1f794256cb2823a0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1connector.html#ae402d364dfc5b6a1f794256cb2823a0d">disconnect</a> ()</td></tr>
<tr class="memdesc:ae402d364dfc5b6a1f794256cb2823a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect the remote entity.  <a href="#ae402d364dfc5b6a1f794256cb2823a0d"></a><br/></td></tr>
<tr class="memitem:ae2de68485ec32d9f944266d6ffb3003e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1connector.html#ae2de68485ec32d9f944266d6ffb3003e">is_connected</a> ()</td></tr>
<tr class="memdesc:ae2de68485ec32d9f944266d6ffb3003e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out whether the object is currently connected.  <a href="#ae2de68485ec32d9f944266d6ffb3003e"></a><br/></td></tr>
<tr class="memitem:a4f59919d2c688e62111133a927ed190c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1connector.html#a4f59919d2c688e62111133a927ed190c">send</a> (const PDU &amp;pdu)</td></tr>
<tr class="memdesc:a4f59919d2c688e62111133a927ed190c"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a PDU to the remote entity.  <a href="#a4f59919d2c688e62111133a927ed190c"></a><br/></td></tr>
<tr class="memitem:a2b10934a5124edc0f78453c50fe36884"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagentxcpp_1_1connector.html#a2b10934a5124edc0f78453c50fe36884">~connector</a> ()</td></tr>
<tr class="memdesc:a2b10934a5124edc0f78453c50fe36884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a2b10934a5124edc0f78453c50fe36884"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Receiving ResponsePDU's works as follows:</p>
<p>The function <a class="el" href="classagentxcpp_1_1connector.html#a9b4effeb519301d589e11fe2914c1f09" title="Wait with timeout for a reponse.">wait_for_response()</a> supports the request-response communication model. After sending a request to the remote entity (using <a class="el" href="classagentxcpp_1_1connector.html#a4f59919d2c688e62111133a927ed190c" title="send a PDU to the remote entity.">send()</a>), <a class="el" href="classagentxcpp_1_1connector.html#a9b4effeb519301d589e11fe2914c1f09" title="Wait with timeout for a reponse.">wait_for_response()</a> is used to wait for the response. It blocks while waiting for a responsePDU from the remote entity, which is then returned to the caller. The <a class="el" href="classagentxcpp_1_1connector.html#a9b4effeb519301d589e11fe2914c1f09" title="Wait with timeout for a reponse.">wait_for_response()</a> function may seem to do synchronous operations only, but this is not true. In fact, it uses an asynchronous receive mechanism, because there may be other PDU's in the queue before the given response is actually received. <a class="el" href="classagentxcpp_1_1connector.html#a9b4effeb519301d589e11fe2914c1f09" title="Wait with timeout for a reponse.">wait_for_response()</a> therefore invokes io_service-&gt;run_one() one ore more times, until the response is received. This may also cause other asynchronous operations to finish. For example, the registered handler object may receive other PDU types, or another asynchronous operation on the io_service object (outside this class or even outside the agentXcpp library) may be served. Here are the steps performed to receive a ResponsePDU:</p>
<ul>
<li>The <a class="el" href="classagentxcpp_1_1connector.html#a9b4effeb519301d589e11fe2914c1f09" title="Wait with timeout for a reponse.">wait_for_response()</a> function puts an empty boost::shared_ptr&lt;&gt; into the responses map, using the PacketID of the awaited ResponsePDU as key.<ul>
<li>The <a class="el" href="classagentxcpp_1_1connector.html#a9b4effeb519301d589e11fe2914c1f09" title="Wait with timeout for a reponse.">wait_for_response()</a> function invokes io_service-&gt;run_one() one or several times, which triggers receive_callback() if data becomes available.</li>
<li>When the receive_callback() function is invoked, it receives a single PDU and processes it as described above.</li>
<li>If a ResponsePDU is received, the registered handler object is not informed by receive_callback(). Instead, the responses map is searched for an entry with the same PacketID as the received ResponsePDU. If found, the received ResponsePDU is stored in the map. Otherwise the ResponsePDU is silently discarded (as nobody waits for it).</li>
<li>The <a class="el" href="classagentxcpp_1_1connector.html#a9b4effeb519301d589e11fe2914c1f09" title="Wait with timeout for a reponse.">wait_for_response()</a> checks its map entry after each run_one() call for a received ResponsePDU. If it finds one, the entry is erased from the map and returned to the caller.</li>
</ul>
</li>
</ul>
<p>The same timeout value is used by all operations which deal with timeouts. The value is stored in the timeout member. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac66b42853b9dd85f3c2b7ee9a0e6bc39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">connector::connector </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; boost::asio::io_service &gt;&#160;</td>
          <td class="paramname"><em>io_service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unix_domain_socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The constructor. </p>
<p>This constructor initializes the connector object to be in disconnected state.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">io_service</td><td>The io_service object needed for boost::asio operations. It may also be used by other parts of the program.</td></tr>
    <tr><td class="paramname">unix_domain_socket</td><td>The path to the unix_domain_socket.</td></tr>
    <tr><td class="paramname">timeout</td><td>The timeout, in milliseconds, for sending and receiving PDU's. See the documentation of the respective methods for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b10934a5124edc0f78453c50fe36884"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classagentxcpp_1_1connector.html#a2b10934a5124edc0f78453c50fe36884">agentxcpp::connector::~connector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a0d5c81d1908b7db51d1080453dd5289b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classagentxcpp_1_1connector.html#a0d5c81d1908b7db51d1080453dd5289b">connector::connect</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connect to the remote entity. </p>
<p>This function connects to the remote entity and starts receiving PDU's. If the object is already connected, the function does nothing.</p>
<dl class="section note"><dt>Note:</dt><dd>While no handler is registered, received PDU's are silently discarded.</dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">disconnected</td><td>If connecting fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae402d364dfc5b6a1f794256cb2823a0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classagentxcpp_1_1connector.html#ae402d364dfc5b6a1f794256cb2823a0d">connector::disconnect</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnect the remote entity. </p>
<p>Stops receiving PDU's and disconnects the remote entity.</p>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae2de68485ec32d9f944266d6ffb3003e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classagentxcpp_1_1connector.html#ae2de68485ec32d9f944266d6ffb3003e">agentxcpp::connector::is_connected</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find out whether the object is currently connected. </p>
<dl class="section return"><dt>Returns:</dt><dd>Whether the object is in state connected.</dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2398a1118dcb2796759c0f74be01f7b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classagentxcpp_1_1connector.html#a2398a1118dcb2796759c0f74be01f7b9">connector::register_handler</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classagentxcpp_1_1connector_1_1pdu__handler.html">pdu_handler</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register a handler object for received PDU's. </p>
<p>Every time a PDU is received, the handler object's handle_pdu() method will be invoked with the PDU as argument. This method is executed in the context of the io_service object's run() or run_one() method. Care should be taken to not block the call, e.g. by doing networking.</p>
<p>After registering a handler it can be unregistered again by calling this function with a null pointer. While no handler object is registered, received PDU's are silently discarded.</p>
<dl class="section note"><dt>Note:</dt><dd>Any exceptions thrown by the handler object are silently discarded.</dd>
<dd>
There can be only one handler object registered at a time.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>A pointer to the handler object, or null.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f59919d2c688e62111133a927ed190c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classagentxcpp_1_1connector.html#a4f59919d2c688e62111133a927ed190c">connector::send</a> </td>
          <td>(</td>
          <td class="paramtype">const PDU &amp;&#160;</td>
          <td class="paramname"><em>pdu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>send a PDU to the remote entity. </p>
<p>The PDU is sent to the remote entity. If the timeout expires during the send operation, a <a class="el" href="classagentxcpp_1_1timeout__error.html" title="Exception to indicate a timeout.">timeout_error</a> is thrown and the object gets disconnected.</p>
<dl class="section note"><dt>Note:</dt><dd>The run_one() of the io_service object is called at least one time by this operation.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pdu</td><td>The PDU to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classagentxcpp_1_1timeout__error.html" title="Exception to indicate a timeout.">timeout_error</a></td><td>If a timeout error occurs. The function uses the timeout value given during construction. The objects gets disconnected in this case. Some data might be sent already.</td></tr>
    <tr><td class="paramname">disconnected</td><td>If disconnected. This is also thrown if sending fails and the object gets disconnected for that reason. Some data might be sent already. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9b4effeb519301d589e11fe2914c1f09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; ResponsePDU &gt; <a class="el" href="classagentxcpp_1_1connector.html#a9b4effeb519301d589e11fe2914c1f09">connector::wait_for_response</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>packetID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait with timeout for a reponse. </p>
<p>This function blocks until a ResponsePDU with the given packetID is received or until the timeout expires, whichever comes first. The received ResponsePDU (if any) is returned.</p>
<p>This function calls run_one() repeatedly on the io_service object until the desired ResponsePDU arrives or the timeout expires. This may cause other asynchronous operations to be served, as well.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">packetID</td><td>The packetID to wait for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">timeout_exception</td><td>If the timeout expired before the ResponsePDU was received. The connector object stays in connected state.</td></tr>
    <tr><td class="paramname">disconnected</td><td>If disconnected. This is also thrown if the operation fails and the object gets disconnected for that reason.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The received ResponsePDU. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/tanjeff/projekte/agentxcpp/src/connector.hpp</li>
<li>/home/tanjeff/projekte/agentxcpp/src/connector.cpp</li>
</ul>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>agentxcpp</b>      </li>
      <li class="navelem"><a class="el" href="classagentxcpp_1_1connector.html">connector</a>      </li>

    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.0 </li>
   </ul>
 </div>


</body>
</html>
